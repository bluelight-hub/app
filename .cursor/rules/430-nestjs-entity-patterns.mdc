---
description: 
globs: packages/backend/**/*.entity.ts
alwaysApply: false
---
# NestJS Entity-Patterns

## Context
- Gilt für alle Entitätsklassen im Backend (`**/*.entity.ts`)
- Standardisiert die Definition von Datenbankmodellen
- Verbessert Konsistenz, Wartbarkeit und Typ-Sicherheit

## Requirements

1. **Struktur und Benennung**
   - Entitätsklassen mit Suffix `Entity` benennen
   - Entity-Dateien mit Namensschema `*.entity.ts`
   - Entitäten in einem `entities`-Verzeichnis der Domäne organisieren
   - Singular für Entitätsnamen verwenden (z.B. `UserEntity`, nicht `UsersEntity`)

2. **Dekoratoren**
   - TypeORM-Dekoratoren für ORM-Mapping
   - `@Entity()` mit explizitem Tabellennamen
   - `@Column()` mit expliziten Typen und Optionen
   - `@Index()` für Leistungsoptimierung bei häufigen Abfragen

3. **Beziehungen**
   - Beziehungstypen korrekt definieren (`@OneToMany`, `@ManyToOne`, etc.)
   - Fremdschlüsseloptionen explizit angeben (onDelete, onUpdate)
   - Bidirektionale Beziehungen korrekt einrichten
   - Zirkuläre Beziehungen mit forwardRef vermeiden

4. **Primärschlüssel**
   - Einheitliche Primärschlüsseldefinition
   - ID-Generierungsstrategie konsistent verwenden
   - Verbundzusammengesetzte Schlüssel bei Bedarf
   - UUIDs für verteilte Systeme verwenden

5. **Datentypen und Validierung**
   - Präzise Datentypentscheidungen treffen
   - Zeichenkettenlängen explizit definieren
   - NOT NULL Constraints wo angemessen
   - Default-Werte für optionale Felder

6. **Metadaten und Tracking**
   - Einheitliche Zeitstempelfelder (createdAt, updatedAt)
   - Auditing-Felder für Benutzeraktionen
   - Soft-Delete wo angemessen
   - Versionierung für Konfliktauflösung

7. **Indizes und Leistung**
   - Indizes für Leistungsoptimierung
   - Spaltentypoptimierung (varchar Länge, etc.)
   - Indexname explizit definieren
   - Zusammengesetzte Indizes für komplexe Abfragen

8. **Erweiterbarkeit**
   - Basisklassen für gemeinsame Felder
   - Vererbung für spezialisierte Entitäten
   - Eingebettete Entitäten für strukturierte Daten
   - Abstrakte Klassen für gemeinsame Muster

## Examples

```typescript
// Gutes Beispiel: BaseEntity mit gemeinsamen Feldern
import {
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  Column,
} from 'typeorm';

/**
 * Basisklasse für alle Entitäten mit gemeinsamen Feldern.
 */
export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({
    type: 'timestamp',
    name: 'created_at',
    comment: 'Erstellungszeitpunkt',
  })
  createdAt: Date;

  @UpdateDateColumn({
    type: 'timestamp',
    name: 'updated_at',
    comment: 'Letzter Aktualisierungszeitpunkt',
  })
  updatedAt: Date;

  @DeleteDateColumn({
    type: 'timestamp',
    name: 'deleted_at',
    nullable: true,
    comment: 'Löschzeitpunkt (Soft-Delete)',
  })
  deletedAt: Date | null;

  @Column({
    type: 'varchar',
    length: 100,
    name: 'created_by',
    nullable: true,
    comment: 'Benutzer-ID des Erstellers',
  })
  createdBy: string | null;

  @Column({
    type: 'varchar',
    length: 100,
    name: 'updated_by',
    nullable: true,
    comment: 'Benutzer-ID des letzten Bearbeiters',
  })
  updatedBy: string | null;

  @Column({
    type: 'int',
    name: 'version',
    default: 1,
    comment: 'Optimistische Sperre für Gleichzeitigkeitskontrolle',
  })
  version: number;
}
```

```typescript
// Gutes Beispiel: UserEntity
import {
  Entity,
  Column,
  Index,
  OneToMany,
  JoinColumn,
  ManyToOne,
} from 'typeorm';
import { BaseEntity } from './base.entity';
import { OrderEntity } from './order.entity';
import { DepartmentEntity } from './department.entity';
import { UserRole } from '../enums/user-role.enum';
import { UserStatus } from '../enums/user-status.enum';

/**
 * Entität für Benutzer im System.
 */
@Entity({ name: 'users' })
@Index('idx_user_email', ['email'], { unique: true })
@Index('idx_user_status', ['status'])
export class UserEntity extends BaseEntity {
  @Column({
    type: 'varchar',
    length: 255,
    name: 'email',
    unique: true,
    comment: 'E-Mail-Adresse des Benutzers',
  })
  email: string;

  @Column({
    type: 'varchar',
    length: 100,
    name: 'name',
    comment: 'Anzeigename des Benutzers',
  })
  name: string;

  @Column({
    type: 'varchar',
    length: 255,
    name: 'password',
    comment: 'Gehashtes Passwort',
    select: false, // Nicht standardmäßig in Abfragen einbeziehen
  })
  password: string;

  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.USER,
    name: 'role',
    comment: 'Rolle des Benutzers',
  })
  role: UserRole;

  @Column({
    type: 'enum',
    enum: UserStatus,
    default: UserStatus.PENDING,
    name: 'status',
    comment: 'Status des Benutzerkontos',
  })
  status: UserStatus;

  @Column({
    type: 'varchar',
    length: 20,
    name: 'phone',
    nullable: true,
    comment: 'Telefonnummer des Benutzers',
  })
  phone: string | null;

  @Column({
    type: 'varchar',
    length: 255,
    name: 'password_reset_token',
    nullable: true,
    select: false, // Nicht standardmäßig in Abfragen einbeziehen
    comment: 'Token zur Passwort-Zurücksetzung',
  })
  passwordResetToken: string | null;

  @Column({
    type: 'timestamp',
    name: 'password_reset_expires',
    nullable: true,
    select: false, // Nicht standardmäßig in Abfragen einbeziehen
    comment: 'Ablaufzeit des Passwort-Zurücksetzungs-Tokens',
  })
  passwordResetExpires: Date | null;

  @Column({
    type: 'boolean',
    name: 'email_verified',
    default: false,
    comment: 'Ist die E-Mail verifiziert',
  })
  emailVerified: boolean;

  @Column({
    type: 'jsonb',
    name: 'settings',
    nullable: true,
    default: '{}',
    comment: 'Benutzerspezifische Einstellungen als JSON',
  })
  settings: Record<string, any> | null;

  // Beziehungen
  @OneToMany(() => OrderEntity, (order) => order.user)
  orders: OrderEntity[];

  @ManyToOne(() => DepartmentEntity, (department) => department.users, {
    nullable: true,
    onDelete: 'SET NULL', // Wenn eine Abteilung gelöscht wird, bleibt der Benutzer erhalten
  })
  @JoinColumn({ name: 'department_id' })
  department: DepartmentEntity | null;
}
```

```typescript
// Beispiel für eine Entität mit zusammengesetztem Primärschlüssel
import { Entity, Column, PrimaryColumn, ManyToOne, JoinColumn } from 'typeorm';
import { UserEntity } from './user.entity';
import { ProductEntity } from './product.entity';

/**
 * Entität für Produkt-Bewertungen mit zusammengesetztem Primärschlüssel.
 */
@Entity({ name: 'product_ratings' })
@Index('idx_rating_score', ['score'])
export class ProductRatingEntity {
  @PrimaryColumn({ name: 'user_id' })
  userId: string;

  @PrimaryColumn({ name: 'product_id' })
  productId: string;

  @Column({
    type: 'int',
    name: 'score',
    comment: 'Bewertungspunktzahl von 1-5',
  })
  score: number;

  @Column({
    type: 'text',
    name: 'comment',
    nullable: true,
    comment: 'Textlicher Kommentar zur Bewertung',
  })
  comment: string | null;

  @Column({
    type: 'timestamp',
    name: 'rated_at',
    default: () => 'CURRENT_TIMESTAMP',
    comment: 'Zeitpunkt der Bewertung',
  })
  ratedAt: Date;

  // Beziehungen mit Join-Columns entsprechend dem zusammengesetzten Schlüssel
  @ManyToOne(() => UserEntity, {
    onDelete: 'CASCADE', // Wenn der Benutzer gelöscht wird, werden auch seine Bewertungen gelöscht
  })
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;

  @ManyToOne(() => ProductEntity, {
    onDelete: 'CASCADE', // Wenn das Produkt gelöscht wird, werden auch die Bewertungen gelöscht
  })
  @JoinColumn({ name: 'product_id' })
  product: ProductEntity;
}
```

```typescript
// Schlechtes Beispiel
@Entity()
class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  email: string; // Kein Typ, Länge oder Index-Definition
  
  @Column()
  pwd: string; // Verwirrende Benennung, keine select: false Option

  @Column()
  role: string; // String statt Enum

  // Fehlende Zeitstempelfelder
  // Fehlende Indizes für häufig abgefragte Felder
  // Keine Dokumentation durch Kommentare
  // Keine expliziten Tabellennamen
  // Kein Entity-Suffix
}
``` 