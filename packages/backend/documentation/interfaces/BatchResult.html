<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>@bluelight-hub/backend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">@bluelight-hub/backend documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  BatchResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/modules/audit/services/audit-log-batch.service.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Interface für Batch-Ergebnisse</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#failed" 
>
                                            failed
                                        </a>
                                </li>
                                <li>
                                        <a href="#failureCount" 
>
                                            failureCount
                                        </a>
                                </li>
                                <li>
                                        <a href="#successCount" 
>
                                            successCount
                                        </a>
                                </li>
                                <li>
                                        <a href="#successful" 
>
                                            successful
                                        </a>
                                </li>
                                <li>
                                        <a href="#totalProcessed" 
>
                                            totalProcessed
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="failed"></a>
                                        <span class="name "><b>failed</b>
                                            <a href="#failed">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>failed:     <code>Array&lt;literal type&gt;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Array&lt;literal type&gt;</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="failureCount"></a>
                                        <span class="name "><b>failureCount</b>
                                            <a href="#failureCount">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>failureCount:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="successCount"></a>
                                        <span class="name "><b>successCount</b>
                                            <a href="#successCount">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>successCount:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="successful"></a>
                                        <span class="name "><b>successful</b>
                                            <a href="#successful">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>successful:         <code><a href="../miscellaneous/variables.html#Audit" target="_self" >AuditLog[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../miscellaneous/variables.html#Audit" target="_self" >AuditLog[]</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="totalProcessed"></a>
                                        <span class="name "><b>totalProcessed</b>
                                            <a href="#totalProcessed">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>totalProcessed:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable, BadRequestException } from &#x27;@nestjs/common&#x27;;
import { PrismaService } from &#x27;../../../prisma/prisma.service&#x27;;
import { CreateAuditLogDto, QueryAuditLogDto } from &#x27;../dto&#x27;;
import { AuditLog, Prisma } from &#x27;@prisma/generated/prisma/client&#x27;;
import { logger } from &#x27;../../../logger/consola.logger&#x27;;
import { ConfigService } from &#x27;@nestjs/config&#x27;;
import { Readable } from &#x27;stream&#x27;;

/**
 * Interface für Batch-Ergebnisse
 */
export interface BatchResult {
  successful: AuditLog[];
  failed: Array&lt;{
    index: number;
    data: CreateAuditLogDto;
    error: string;
  }&gt;;
  totalProcessed: number;
  successCount: number;
  failureCount: number;
}

/**
 * Interface für Retention-Konfiguration
 */
export interface RetentionConfig {
  defaultRetentionDays: number;
  severityRetention: {
    LOW: number;
    MEDIUM: number;
    HIGH: number;
    CRITICAL: number;
  };
  complianceRetention: {
    [key: string]: number;
  };
}

/**
 * Service für Batch-Verarbeitung und erweiterte Audit-Log-Funktionen
 * Bietet Batch-Operationen, Validierung und konfigurierbare Retention
 */
@Injectable()
export class AuditLogBatchService {
  private readonly batchSize: number;
  private readonly retentionConfig: RetentionConfig;

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {
    // Batch-Größe aus Konfiguration oder Standard
    this.batchSize &#x3D; this.configService.get&lt;number&gt;(&#x27;AUDIT_BATCH_SIZE&#x27;, 100);

    // Retention-Konfiguration
    this.retentionConfig &#x3D; {
      defaultRetentionDays: this.configService.get&lt;number&gt;(&#x27;AUDIT_DEFAULT_RETENTION_DAYS&#x27;, 365),
      severityRetention: {
        LOW: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_LOW&#x27;, 90),
        MEDIUM: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_MEDIUM&#x27;, 180),
        HIGH: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_HIGH&#x27;, 365),
        CRITICAL: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_CRITICAL&#x27;, 730),
      },
      complianceRetention: {
        GDPR: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_GDPR&#x27;, 1095), // 3 Jahre
        HIPAA: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_HIPAA&#x27;, 2190), // 6 Jahre
        SOX: this.configService.get&lt;number&gt;(&#x27;AUDIT_RETENTION_SOX&#x27;, 2555), // 7 Jahre
      },
    };
  }

  /**
   * Validiert einen Audit-Log-Eintrag vor der Persistierung
   * @param dto Audit-Log-Daten
   * @returns Validierungsergebnis
   */
  private validateAuditLog(dto: CreateAuditLogDto): { isValid: boolean; errors: string[] } {
    const errors: string[] &#x3D; [];

    // Pflichtfelder validieren
    if (!dto.actionType) {
      errors.push(&#x27;actionType is required&#x27;);
    }
    if (!dto.action || dto.action.length &#x3D;&#x3D;&#x3D; 0) {
      errors.push(&#x27;action is required and cannot be empty&#x27;);
    }
    if (!dto.resource || dto.resource.length &#x3D;&#x3D;&#x3D; 0) {
      errors.push(&#x27;resource is required and cannot be empty&#x27;);
    }

    // Längenvalidierung
    if (dto.action &amp;&amp; dto.action.length &gt; 100) {
      errors.push(&#x27;action must not exceed 100 characters&#x27;);
    }
    if (dto.resource &amp;&amp; dto.resource.length &gt; 100) {
      errors.push(&#x27;resource must not exceed 100 characters&#x27;);
    }
    if (dto.resourceId &amp;&amp; dto.resourceId.length &gt; 255) {
      errors.push(&#x27;resourceId must not exceed 255 characters&#x27;);
    }

    // Timestamp-Validierung entfernt, da timestamp nicht im DTO enthalten ist

    // IP-Adresse validieren (IPv4 oder IPv6)
    if (dto.ipAddress) {
      const ipv4Pattern &#x3D; /^(\d{1,3}\.){3}\d{1,3}$/;
      const ipv6Pattern &#x3D; /^([\da-fA-F]{1,4}:){7}[\da-fA-F]{1,4}$/;
      if (!ipv4Pattern.test(dto.ipAddress) &amp;&amp; !ipv6Pattern.test(dto.ipAddress)) {
        errors.push(&#x27;ipAddress must be a valid IPv4 or IPv6 address&#x27;);
      }
    }

    // HTTP-Methode validieren
    if (dto.httpMethod) {
      const validMethods &#x3D; [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;PATCH&#x27;, &#x27;DELETE&#x27;, &#x27;HEAD&#x27;, &#x27;OPTIONS&#x27;];
      if (!validMethods.includes(dto.httpMethod.toUpperCase())) {
        errors.push(&#x60;httpMethod must be one of: ${validMethods.join(&#x27;, &#x27;)}&#x60;);
      }
    }

    // Status-Code validieren
    if (dto.statusCode &amp;&amp; (dto.statusCode &lt; 100 || dto.statusCode &gt; 599)) {
      errors.push(&#x27;statusCode must be a valid HTTP status code (100-599)&#x27;);
    }

    return {
      isValid: errors.length &#x3D;&#x3D;&#x3D; 0,
      errors,
    };
  }

  /**
   * Transformiert Audit-Log-Daten vor der Persistierung
   * @param dto Audit-Log-Daten
   * @returns Transformierte Daten
   */
  private transformAuditLog(dto: CreateAuditLogDto): CreateAuditLogDto {
    const transformed &#x3D; { ...dto };

    // Retention-Period basierend auf Severity und Compliance setzen
    if (!transformed.retentionPeriod) {
      transformed.retentionPeriod &#x3D; this.calculateRetentionPeriod(dto);
    }

    // Timestamp wird automatisch beim Insert gesetzt

    // HTTP-Methode normalisieren
    if (transformed.httpMethod) {
      transformed.httpMethod &#x3D; transformed.httpMethod.toUpperCase();
    }

    // Felder trimmen
    if (transformed.action) transformed.action &#x3D; transformed.action.trim();
    if (transformed.resource) transformed.resource &#x3D; transformed.resource.trim();
    if (transformed.resourceId) transformed.resourceId &#x3D; transformed.resourceId.trim();
    if (transformed.userEmail) transformed.userEmail &#x3D; transformed.userEmail.trim().toLowerCase();

    return transformed;
  }

  /**
   * Berechnet die Aufbewahrungsdauer basierend auf Severity und Compliance
   * @param dto Audit-Log-Daten
   * @returns Aufbewahrungsdauer in Tagen
   */
  private calculateRetentionPeriod(dto: CreateAuditLogDto): number {
    let retentionDays &#x3D; this.retentionConfig.defaultRetentionDays;

    // Severity-basierte Retention (verwende direkt den Severity-Wert, nicht das Maximum)
    if (dto.severity &amp;&amp; this.retentionConfig.severityRetention[dto.severity]) {
      retentionDays &#x3D; this.retentionConfig.severityRetention[dto.severity];
    }

    // Compliance-basierte Retention (überschreibt Severity-basierte, wenn höher)
    if (dto.compliance &amp;&amp; dto.compliance.length &gt; 0) {
      for (const complianceTag of dto.compliance) {
        if (this.retentionConfig.complianceRetention[complianceTag]) {
          retentionDays &#x3D; Math.max(
            retentionDays,
            this.retentionConfig.complianceRetention[complianceTag],
          );
        }
      }
    }

    return retentionDays;
  }

  /**
   * Erstellt mehrere Audit-Log-Einträge in einem Batch
   * @param dtos Array von Audit-Log-Daten
   * @returns Batch-Ergebnis mit erfolgreichen und fehlgeschlagenen Einträgen
   */
  async createBatch(dtos: CreateAuditLogDto[]): Promise&lt;BatchResult&gt; {
    const result: BatchResult &#x3D; {
      successful: [],
      failed: [],
      totalProcessed: dtos.length,
      successCount: 0,
      failureCount: 0,
    };

    // Verarbeite in Batches für bessere Performance
    for (let i &#x3D; 0; i &lt; dtos.length; i +&#x3D; this.batchSize) {
      const batch &#x3D; dtos.slice(i, i + this.batchSize);
      const validatedBatch: CreateAuditLogDto[] &#x3D; [];

      // Validiere und transformiere jeden Eintrag
      for (let j &#x3D; 0; j &lt; batch.length; j++) {
        const dto &#x3D; batch[j];
        const validation &#x3D; this.validateAuditLog(dto);

        if (!validation.isValid) {
          result.failed.push({
            index: i + j,
            data: dto,
            error: validation.errors.join(&#x27;; &#x27;),
          });
          result.failureCount++;
          continue;
        }

        validatedBatch.push(this.transformAuditLog(dto));
      }

      // Batch-Insert für validierte Einträge
      if (validatedBatch.length &gt; 0) {
        try {
          const created &#x3D; await this.prisma.auditLog.createMany({
            data: validatedBatch.map((dto) &#x3D;&gt; ({
              ...dto,
              // Setze Standard-Werte falls nicht übertragen
              severity: dto.severity || &#x27;MEDIUM&#x27;,
              success: dto.success ?? true,
              sensitiveData: dto.sensitiveData || false,
              requiresReview: dto.requiresReview || false,
              compliance: dto.compliance || [],
              affectedFields: dto.affectedFields || [],
            })),
            skipDuplicates: true,
          });

          // Da createMany keine erstellten Objekte zurückgibt, müssen wir sie separat abrufen
          const createdLogs &#x3D; await this.prisma.auditLog.findMany({
            where: {
              timestamp: {
                gte: new Date(Date.now() - 1000), // Letzte Sekunde
              },
            },
            orderBy: {
              timestamp: &#x27;desc&#x27;,
            },
            take: created.count,
          });

          result.successful.push(...createdLogs);
          result.successCount +&#x3D; created.count;

          // Batch creation completed
        } catch (error) {
          // Bei Batch-Fehler alle Einträge als fehlgeschlagen markieren
          for (let j &#x3D; 0; j &lt; validatedBatch.length; j++) {
            result.failed.push({
              index: i + j,
              data: batch[j],
              error: error.message || &#x27;Batch insert failed&#x27;,
            });
            result.failureCount++;
          }

          logger.error(&#x27;Failed to create batch audit logs&#x27;, {
            error: error.message,
            batchSize: validatedBatch.length,
          });
        }
      }
    }

    // Batch processing completed

    return result;
  }

  /**
   * Löscht Audit-Logs basierend auf Retention-Policy
   * @returns Anzahl gelöschter Einträge
   */
  async applyRetentionPolicy(): Promise&lt;number&gt; {
    try {
      const now &#x3D; new Date();
      let totalDeleted &#x3D; 0;

      // Lösche Einträge basierend auf retentionPeriod
      const deleteWithRetention &#x3D; await this.prisma.auditLog.deleteMany({
        where: {
          AND: [
            { retentionPeriod: { not: null } },
            {
              timestamp: {
                lt: new Date(now.getTime() - 24 * 60 * 60 * 1000), // Mindestens 1 Tag alt
              },
            },
          ],
          // Berechne ob Retention abgelaufen ist
          // Hinweis: Dies ist eine vereinfachte Version, in Produktion würde man
          // einen scheduled Job verwenden, der das Datum berechnet
        },
      });

      totalDeleted +&#x3D; deleteWithRetention.count;

      // Lösche alte archivierte Einträge
      const deleteArchived &#x3D; await this.prisma.auditLog.deleteMany({
        where: {
          archivedAt: {
            lt: new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000), // 90 Tage nach Archivierung
          },
        },
      });

      totalDeleted +&#x3D; deleteArchived.count;

      // Retention policy applied

      return totalDeleted;
    } catch (error) {
      logger.error(&#x27;Failed to apply retention policy&#x27;, {
        error: error.message,
      });
      throw new BadRequestException(&#x27;Failed to apply retention policy&#x27;);
    }
  }

  /**
   * Erstellt aggregierte Statistiken für einen bestimmten Zeitraum
   * @param startDate Startdatum
   * @param endDate Enddatum
   * @param groupBy Gruppierung (hour, day, week, month)
   * @returns Aggregierte Statistiken
   */
  async getAggregatedStatistics(
    startDate: Date,
    endDate: Date,
    groupBy: &#x27;hour&#x27; | &#x27;day&#x27; | &#x27;week&#x27; | &#x27;month&#x27; &#x3D; &#x27;day&#x27;,
  ) {
    try {
      // Basis-WHERE-Bedingung
      const where: Prisma.AuditLogWhereInput &#x3D; {
        timestamp: {
          gte: startDate,
          lte: endDate,
        },
      };

      // Gruppierung nach Zeitintervall (vereinfachte Version)
      // In Produktion würde man SQL-Funktionen für die Gruppierung verwenden
      const logs &#x3D; await this.prisma.auditLog.findMany({
        where,
        select: {
          timestamp: true,
          actionType: true,
          severity: true,
          success: true,
          resource: true,
        },
        orderBy: {
          timestamp: &#x27;asc&#x27;,
        },
      });

      // Manuelle Aggregation (vereinfacht)
      const aggregated &#x3D; new Map&lt;string, any&gt;();

      for (const log of logs) {
        let key: string;
        const date &#x3D; new Date(log.timestamp);

        switch (groupBy) {
          case &#x27;hour&#x27;:
            key &#x3D; &#x60;${date.toISOString().slice(0, 13)}:00&#x60;;
            break;
          case &#x27;day&#x27;:
            key &#x3D; date.toISOString().slice(0, 10);
            break;
          case &#x27;week&#x27;: {
            const week &#x3D; Math.floor(date.getTime() / (7 * 24 * 60 * 60 * 1000));
            key &#x3D; &#x60;Week ${week}&#x60;;
            break;
          }
          case &#x27;month&#x27;:
            key &#x3D; date.toISOString().slice(0, 7);
            break;
        }

        if (!aggregated.has(key)) {
          aggregated.set(key, {
            period: key,
            total: 0,
            byActionType: {},
            bySeverity: {},
            byResource: {},
            successRate: { success: 0, failed: 0 },
          });
        }

        const stats &#x3D; aggregated.get(key);
        stats.total++;

        // Action Type
        stats.byActionType[log.actionType] &#x3D; (stats.byActionType[log.actionType] || 0) + 1;

        // Severity
        stats.bySeverity[log.severity] &#x3D; (stats.bySeverity[log.severity] || 0) + 1;

        // Resource
        stats.byResource[log.resource] &#x3D; (stats.byResource[log.resource] || 0) + 1;

        // Success Rate
        if (log.success) {
          stats.successRate.success++;
        } else {
          stats.successRate.failed++;
        }
      }

      const result &#x3D; Array.from(aggregated.values()).map((stats) &#x3D;&gt; ({
        ...stats,
        successRate: {
          ...stats.successRate,
          percentage:
            stats.total &gt; 0 ? Math.round((stats.successRate.success / stats.total) * 100) : 0,
        },
      }));

      // Generated aggregated statistics

      return result;
    } catch (error) {
      logger.error(&#x27;Failed to generate aggregated statistics&#x27;, {
        error: error.message,
        startDate,
        endDate,
        groupBy,
      });
      throw new BadRequestException(&#x27;Failed to generate aggregated statistics&#x27;);
    }
  }

  /**
   * Exportiert Audit-Logs in verschiedenen Formaten
   * @param queryDto Abfrage-Parameter
   * @param format Export-Format
   * @returns Exportierte Daten
   */
  async exportLogs(
    queryDto: QueryAuditLogDto,
    format: &#x27;json&#x27; | &#x27;csv&#x27; | &#x27;ndjson&#x27; &#x3D; &#x27;json&#x27;,
  ): Promise&lt;string&gt; {
    try {
      // Build where clause from query DTO
      const where: Prisma.AuditLogWhereInput &#x3D; {};

      // Apply filters from queryDto
      if (queryDto.actionType) where.actionType &#x3D; queryDto.actionType;
      if (queryDto.severity) where.severity &#x3D; queryDto.severity;
      if (queryDto.action) where.action &#x3D; { contains: queryDto.action, mode: &#x27;insensitive&#x27; };
      if (queryDto.resource) where.resource &#x3D; { contains: queryDto.resource, mode: &#x27;insensitive&#x27; };
      if (queryDto.resourceId) where.resourceId &#x3D; queryDto.resourceId;
      if (queryDto.userId) where.userId &#x3D; queryDto.userId;
      if (queryDto.userEmail)
        where.userEmail &#x3D; { contains: queryDto.userEmail, mode: &#x27;insensitive&#x27; };
      if (queryDto.userRole) where.userRole &#x3D; queryDto.userRole;
      if (queryDto.success !&#x3D;&#x3D; undefined) where.success &#x3D; queryDto.success;

      // Date range filter
      if (queryDto.startDate || queryDto.endDate) {
        where.timestamp &#x3D; {};
        if (queryDto.startDate) where.timestamp.gte &#x3D; new Date(queryDto.startDate);
        if (queryDto.endDate) where.timestamp.lte &#x3D; new Date(queryDto.endDate);
      }

      const logs &#x3D; await this.prisma.auditLog.findMany({
        where,
        orderBy: {
          timestamp: &#x27;desc&#x27;,
        },
      });

      // Exporting logs

      switch (format) {
        case &#x27;json&#x27;:
          return JSON.stringify(logs, null, 2);

        case &#x27;ndjson&#x27;:
          return logs.map((log) &#x3D;&gt; JSON.stringify(log)).join(&#x27;\n&#x27;);

        case &#x27;csv&#x27;: {
          // Einfache CSV-Implementierung
          const headers &#x3D; [
            &#x27;id&#x27;,
            &#x27;timestamp&#x27;,
            &#x27;actionType&#x27;,
            &#x27;severity&#x27;,
            &#x27;action&#x27;,
            &#x27;resource&#x27;,
            &#x27;resourceId&#x27;,
            &#x27;userId&#x27;,
            &#x27;userEmail&#x27;,
            &#x27;userRole&#x27;,
            &#x27;ipAddress&#x27;,
            &#x27;success&#x27;,
            &#x27;statusCode&#x27;,
            &#x27;errorMessage&#x27;,
          ];

          const csvRows &#x3D; [headers.join(&#x27;,&#x27;)];

          for (const log of logs) {
            const row &#x3D; headers.map((header) &#x3D;&gt; {
              const value &#x3D; log[header];
              if (value &#x3D;&#x3D;&#x3D; null || value &#x3D;&#x3D;&#x3D; undefined) return &#x27;&#x27;;
              if (typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; value.includes(&#x27;,&#x27;)) {
                return &#x60;&quot;${value.replace(/&quot;/g, &#x27;&quot;&quot;&#x27;)}&quot;&#x60;;
              }
              return String(value);
            });
            csvRows.push(row.join(&#x27;,&#x27;));
          }

          return csvRows.join(&#x27;\n&#x27;);
        }

        default:
          throw new BadRequestException(&#x60;Unsupported export format: ${format}&#x60;);
      }
    } catch (error) {
      logger.error(&#x27;Failed to export audit logs&#x27;, {
        error: error.message,
        format,
      });
      // Wenn es schon ein BadRequestException ist, werfe es direkt weiter
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException(&#x27;Failed to export audit logs&#x27;);
    }
  }

  /**
   * Exportiert Audit-Logs als Stream für große Datenmengen
   * @param queryDto Abfrage-Parameter
   * @param format Export-Format
   * @returns Readable Stream
   */
  async exportLogsStream(
    queryDto: QueryAuditLogDto,
    format: &#x27;json&#x27; | &#x27;csv&#x27; | &#x27;ndjson&#x27; &#x3D; &#x27;json&#x27;,
  ): Promise&lt;Readable&gt; {
    try {
      // Build where clause from query DTO
      const where: Prisma.AuditLogWhereInput &#x3D; {};

      // Apply filters from queryDto
      if (queryDto.actionType) where.actionType &#x3D; queryDto.actionType;
      if (queryDto.severity) where.severity &#x3D; queryDto.severity;
      if (queryDto.action) where.action &#x3D; { contains: queryDto.action, mode: &#x27;insensitive&#x27; };
      if (queryDto.resource) where.resource &#x3D; { contains: queryDto.resource, mode: &#x27;insensitive&#x27; };
      if (queryDto.resourceId) where.resourceId &#x3D; queryDto.resourceId;
      if (queryDto.userId) where.userId &#x3D; queryDto.userId;
      if (queryDto.userEmail)
        where.userEmail &#x3D; { contains: queryDto.userEmail, mode: &#x27;insensitive&#x27; };
      if (queryDto.userRole) where.userRole &#x3D; queryDto.userRole;
      if (queryDto.success !&#x3D;&#x3D; undefined) where.success &#x3D; queryDto.success;

      // Date range filter
      if (queryDto.startDate || queryDto.endDate) {
        where.timestamp &#x3D; {};
        if (queryDto.startDate) where.timestamp.gte &#x3D; new Date(queryDto.startDate);
        if (queryDto.endDate) where.timestamp.lte &#x3D; new Date(queryDto.endDate);
      }

      // Create cursor-based pagination stream
      const batchSize &#x3D; 1000;
      let cursor: string | undefined &#x3D; undefined;
      let isFirstBatch &#x3D; true;
      let recordCount &#x3D; 0;

      // Create readable stream
      const prisma &#x3D; this.prisma;
      const stream &#x3D; new Readable({
        async read() {
          try {
            const findManyArgs: Prisma.AuditLogFindManyArgs &#x3D; {
              where,
              orderBy: { timestamp: &#x27;desc&#x27; },
              take: batchSize,
            };

            if (cursor) {
              findManyArgs.cursor &#x3D; { id: cursor };
              findManyArgs.skip &#x3D; 1; // Skip the cursor record
            }

            const logs &#x3D; await prisma.auditLog.findMany(findManyArgs);

            if (logs.length &#x3D;&#x3D;&#x3D; 0) {
              // End of data
              if (format &#x3D;&#x3D;&#x3D; &#x27;json&#x27;) {
                this.push(isFirstBatch ? &#x27;[]&#x27; : &#x27;\n]&#x27;);
              }
              this.push(null); // Signal end of stream
              logger.trace(&#x60;Export stream completed with ${recordCount} records&#x60;);
              return;
            }

            // Process batch
            switch (format) {
              case &#x27;json&#x27;:
                if (isFirstBatch) {
                  this.push(&#x27;[\n&#x27;);
                }
                logs.forEach((log, index) &#x3D;&gt; {
                  const isLast &#x3D; index &#x3D;&#x3D;&#x3D; logs.length - 1;
                  const comma &#x3D; !isFirstBatch || index &gt; 0 ? &#x27;,&#x27; : &#x27;&#x27;;
                  this.push(comma + JSON.stringify(log));
                  if (!isLast) this.push(&#x27;\n&#x27;);
                });
                break;

              case &#x27;ndjson&#x27;:
                logs.forEach((log) &#x3D;&gt; {
                  this.push(JSON.stringify(log) + &#x27;\n&#x27;);
                });
                break;

              case &#x27;csv&#x27;:
                if (isFirstBatch) {
                  const headers &#x3D; [
                    &#x27;id&#x27;,
                    &#x27;timestamp&#x27;,
                    &#x27;actionType&#x27;,
                    &#x27;severity&#x27;,
                    &#x27;action&#x27;,
                    &#x27;resource&#x27;,
                    &#x27;resourceId&#x27;,
                    &#x27;userId&#x27;,
                    &#x27;userEmail&#x27;,
                    &#x27;userRole&#x27;,
                    &#x27;ipAddress&#x27;,
                    &#x27;success&#x27;,
                    &#x27;statusCode&#x27;,
                    &#x27;errorMessage&#x27;,
                  ];
                  this.push(headers.join(&#x27;,&#x27;) + &#x27;\n&#x27;);
                }

                logs.forEach((log) &#x3D;&gt; {
                  const row &#x3D; [
                    log.id,
                    log.timestamp.toISOString(),
                    log.actionType,
                    log.severity,
                    log.action || &#x27;&#x27;,
                    log.resource || &#x27;&#x27;,
                    log.resourceId || &#x27;&#x27;,
                    log.userId || &#x27;&#x27;,
                    log.userEmail || &#x27;&#x27;,
                    log.userRole || &#x27;&#x27;,
                    log.ipAddress || &#x27;&#x27;,
                    log.success,
                    log.statusCode || &#x27;&#x27;,
                    log.errorMessage || &#x27;&#x27;,
                  ].map((value) &#x3D;&gt; {
                    if (value &#x3D;&#x3D;&#x3D; null || value &#x3D;&#x3D;&#x3D; undefined) return &#x27;&#x27;;
                    const str &#x3D; String(value);
                    if (str.includes(&#x27;,&#x27;) || str.includes(&#x27;&quot;&#x27;) || str.includes(&#x27;\n&#x27;)) {
                      return &#x60;&quot;${str.replace(/&quot;/g, &#x27;&quot;&quot;&#x27;)}&quot;&#x60;;
                    }
                    return str;
                  });
                  this.push(row.join(&#x27;,&#x27;) + &#x27;\n&#x27;);
                });
                break;
            }

            recordCount +&#x3D; logs.length;
            cursor &#x3D; logs[logs.length - 1].id;
            isFirstBatch &#x3D; false;

            // If we got less than batchSize, we&#x27;re at the end
            if (logs.length &lt; batchSize) {
              if (format &#x3D;&#x3D;&#x3D; &#x27;json&#x27;) {
                this.push(&#x27;\n]&#x27;);
              }
              this.push(null);
              logger.trace(&#x60;Export stream completed with ${recordCount} records&#x60;);
            }
          } catch (error) {
            logger.error(&#x27;Stream read error&#x27;, { error: error.message });
            this.destroy(error);
          }
        },
      });

      return stream;
    } catch (error) {
      logger.error(&#x27;Failed to create export stream&#x27;, {
        error: error.message,
        format,
      });
      throw new BadRequestException(&#x27;Failed to create export stream&#x27;);
    }
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'BatchResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
