Zusammenfassung der Aufgabe
Du möchtest ein Einsatztagebuch (ETB) in Deiner Anwendung implementieren. Dabei sollen sowohl automatische als auch manuelle Einträge protokolliert und revisionssicher gespeichert werden. Dein Junior-Dev soll dies in Angriff nehmen und Schritt für Schritt umsetzen können.

Im Folgenden findest Du einen Implementierungsplan in mehreren Phasen, der sich sowohl an Best Practices als auch an den oben beschriebenen ETB-Anforderungen orientiert. Er gibt Deinem Junior-Dev eine klare Roadmap, was zu tun ist, in welcher Reihenfolge und worauf er besonders achten muss.

⸻

1. Datenbank-Design und -Vorbereitung

1.1 Datenmodell entwerfen
	•	Ziel: Tabellen- und Feldstruktur für das Einsatztagebuch erstellen.
	•	Aufgaben:
	1.	[X] Tabellenstruktur für EinsatztagebuchEintrag
	•	[X] id (string/UUID, Primary Key)
	•	[X] timestampErstellung (datetime)
	•	[X] timestampEreignis (datetime)
	•	[X] autorId (string, verweist auf User-Tabelle)
	•	[X] autorName (optional, falls du den Namen direkt speichern willst)
	•	[X] autorRolle (optional, falls du die Rolle mit abspeichern willst)
	•	[X] kategorie (string)
	•	[X] titel (string, optional)
	•	[X] beschreibung (text)
	•	[X] referenzEinsatzId (string, optional)
	•	[X] referenzPatientId (string, optional)
	•	[X] referenzEinsatzmittelId (string, optional)
	•	[X] systemQuelle (string, optional)
	•	[X] version (number)
	•	[X] istAbgeschlossen (boolean)
	•	[X] timestampAbschluss (datetime, optional)
	•	[X] abgeschlossenVon (string, optional)
	2.	[X] Tabellenstruktur für Anlage
	•	[X] id (string/UUID, Primary Key)
	•	[X] etbEintragId (string, Foreign Key zu EinsatztagebuchEintrag.id)
	•	[X] dateiname (string)
	•	[X] dateityp (string)
	•	[X] speicherOrt (string)
	•	[X] beschreibung (text, optional)
	3.	[X] Tabellen für Benutzer/User (falls noch nicht vorhanden)
	•	[X] id, name, rolle, … (abhängig vom Rest der Anwendung)
	•	[X] Ergebnis: Migrationsskripte (z. B. mit TypeORM oder Prisma) erstellen, damit Tabellen in SQLite (bzw. der verwendeten DB) angelegt werden.

1.2 Implementierung der Migrations
	•	Ziel: Die Tabellen und erforderlichen Indizes in der Datenbank anlegen.
	•	Aufgaben:
	•	[X] Migrationsdateien erstellen (z. B. npx prisma migrate dev oder TypeORM migration:generate).
	•	[X] Testen, ob das Datenmodell sich anlegen und wieder rückgängig machen lässt (roll forward / roll back).

⸻

2. Backend-Implementierung (NestJS)

2.1 REST-Endpoints oder GraphQL-Schema definieren
	•	Ziel: Klarer Endpunkt bzw. Resolver, um Einsatztagebuch-Einträge anzulegen, abzurufen und zu schließen.
	•	Aufgaben:
	1.	[X] Neuen Eintrag anlegen (POST /etb)
	•	[X] Request-Body enthält die benötigten Felder: timestampEreignis, beschreibung, kategorie, etc.
	•	[X] Automatisch: timestampErstellung und autor (aus JWT/Session) ergänzen.
	•	[X] Optional: Validierung (z. B. mit class-validator).
	2.	[X] Einträge abrufen (GET /etb)
	•	[X] Paginierung und Filterung (z. B. by referenzEinsatzId oder kategorie).
	•	[X] Sortierung in chronologischer Reihenfolge (standardmäßig).
	3.	[X] Eintrag schließen (PUT/PATCH /etb/:id/schliessen)
	•	[X] Setzt istAbgeschlossen = true, timestampAbschluss = now(), abgeschlossenVon = autorId.
	•	[X] Danach dürfen keine weiteren Änderungen möglich sein.
	4.	[X] Anhänge hochladen (POST /etb/:id/anlage)
	•	[X] Annahme einer Datei (multipart/form-data), Speichern im definierten speicherOrt, Eintrag in die Anlage-Tabelle.

2.2 Service-Layer implementieren
	•	Ziel: Kapselung der Datenbank-Operationen (CRUD) in einer NestJS-Serviceklasse.
	•	Aufgaben:
	1.	[X] EinsatztagebuchService
	•	[X] createEintrag(dto: CreateEtbDto): Legt neuen Eintrag an, setzt initial version = 1, istAbgeschlossen = false.
	•	[X] findAll(filter?: FilterEtbDto): Gibt Liste aller Einträge (mit Filteroptionen).
	•	[X] findOne(id: string): Einzelnen Eintrag abrufen.
	•	[X] updateEintrag(id: string, changes: UpdateEtbDto): Erhöht ggf. version, speichert Änderungen (nur solange istAbgeschlossen = false).
	•	[X] closeEintrag(id: string): Schließt den Eintrag ab (keine weiteren Änderungen).
	2.	[X] AnlagenService
	•	[X] addAnlage(eintragId: string, file: Express.Multer.File): Speichert Datei, legt DB-Eintrag in Anlage an.
	•	[X] getAnlagenByEintragId(eintragId: string): Gibt Liste mit Metadaten zu Anhängen zurück.

2.3 Automatische Einträge (Hooks)
	•	Ziel: Bestimmte Ereignisse im System sollen automatisch einen ETB-Eintrag generieren.
	•	Aufgaben:
	1.	[X] Definieren, welche Events → Eintrag (z. B. Statuswechsel eines Einsatzmittels, Anlage eines Patienten).
	2.	[X] Im Code: Event Listener oder Interceptor anlegen, der den EinsatztagebuchService.createEintrag(...) aufruft.
	3.	[X] Sicherstellen, dass die systemQuelle (z. B. "Automatisch: EINSATZMITTEL_STATUSWECHSEL") korrekt gesetzt wird.

⸻

3. Frontend-Implementierung (React + ViteJS + Tauri)

3.1 Grundgerüst für ETB-Seite
	•	Ziel: Übersicht aller ETB-Einträge und Detailansicht in einer React-Page (z. B. ETBOverview.tsx und ETBDetail.tsx).
	•	Aufgaben:
	1.	[ ] ETB-Übersicht (Liste)
	•	[ ] Einfache Tabelle oder Timeline-Komponente, die Daten vom Endpoint /etb lädt.
	•	[ ] Filteroptionen: z. B. nach Einsatz, nach Zeitraum, nach Kategorie.
	2.	[ ] Neuer-Eintrag-Button
	•	[ ] Klick → Modal oder Separate Page mit Formular: kategorie, beschreibung, timestampEreignis, …
	•	[ ] On Submit → POST an Backend → Liste aktualisieren.
	3.	[ ] Detailansicht
	•	[ ] Klick auf einen Eintrag → Anzeige aller Felder + evtl. Historie (Version).
	•	[ ] Möglichkeit, Anhänge anzusehen oder herunterzuladen.

3.2 Bearbeitungslogik
	•	Ziel: Eintrag bearbeiten, solange istAbgeschlossen = false.
	•	Aufgaben:
	1.	[ ] Bei Klick auf "Bearbeiten" → Formular öffnen, Felder editieren.
	2.	[ ] On Save → PUT/PATCH an Backend → Liste aktualisieren.
	3.	[ ] Falls istAbgeschlossen = true, Bearbeiten-Button deaktivieren oder nicht anzeigen.

3.3 Abschließen eines Eintrags / Gesamtes ETB
	•	Ziel: Eintrag (oder ganzer Einsatz) abschließen.
	•	Aufgaben:
	1.	[ ] "Einsatztagebuch abschließen" (Button) → Bestätigungsdialog, dann POST an /etb/:id/schliessen oder /einsatz/:id/schliessenETB.
	2.	[ ] Aus UI-Sicht: Felder werden "read-only" angezeigt.
	3.	[ ] Nach Abschluss: Export-PDF-Knopf (s. 4.2).

3.4 Anhänge und Upload
	•	Ziel: Datei-Upload zu ETB-Einträgen.
	•	Aufgaben:
	1.	[ ] Dateiauswahl (z. B. <input type="file" />), POST an /etb/:id/anlage.
	2.	[ ] Liste hochgeladener Dateien anzeigen (inkl. Download-Link).
	3.	[ ] Darstellung von Dateinamen, Dateityp und ggf. einer kleinen Vorschau (Bild, PDF).

⸻

4. Weitere wichtige Aspekte

4.1 Revisionssicherheit / Versionierung
	•	Ziel: Änderungsverfolgung, solange Eintrag nicht final abgeschlossen.
	•	Aufgaben:
	1.	[X] In updateEintrag die version hochzählen.
	2.	[ ] Ggf. Detailtabelle für Revisionen anlegen (z. B. EinsatztagebuchEintrag_Historie).
	3.	[ ] Im UI Version oder Änderungshistorie anzeigen, falls gewünscht.

4.2 PDF-Export / Archivierung
	•	Ziel: Einsatztagebuch als PDF (oder PDF/A) exportieren, um es revisionssicher zu archivieren.
	•	Aufgaben:
	1.	[ ] Route (z. B. GET /etb/:id/pdf), die ein PDF rendert und zurückgibt.
	2.	[ ] Tooling: z. B. pdfmake, jspdf oder serverseitig eine PDF-Bibliothek (NestJS) nutzen.
	3.	[ ] Liste aller Einträge + Anhänge (ggf. als separate PDF-Anhänge oder verlinkt) einbinden.
	4.	[ ] Format: Wichtige Felder im Kopfbereich (Datum, Autor, Version, …), dann tabellarische Darstellung der Einträge in chronologischer Reihenfolge.

4.3 Rollen- und Rechteverwaltung
	•	Ziel: Nur bestimmte Benutzer dürfen ETB-Einträge erstellen, bearbeiten oder abschließen.
	•	Aufgaben:
	1.	[X] Authentifizierung (JWT, Sessions) im NestJS.
	2.	[ ] Autorisierung: Guards oder Middleware, die sicherstellen, dass ein Benutzer nur Einträge in seinem Zuständigkeitsbereich bearbeiten kann.
	3.	[ ] Für Junior-Dev: Definition der Rollen (z. B. Admin, S2, S3, Sanitäter, Leser).
	4.	[ ] Frontend: Buttons nur anzeigen, wenn der Benutzer die notwendigen Rechte hat.

4.4 Tests (Unit & Integration)
	•	Ziel: Qualität und Stabilität sicherstellen.
	•	Aufgaben:
	1.	[ ] Unit-Tests für Services (z. B. EinsatztagebuchService):
	•	[ ] createEintrag, updateEintrag, closeEintrag usw.
	2.	[ ] Integrationstests für Endpoints:
	•	[ ] POST /etb → Eintrag existiert in DB.
	•	[ ] PATCH /etb/:id → Version wird hochgezählt, nur solange istAbgeschlossen = false.
	•	[ ] PATCH /etb/:id/schliessen → Keine weiteren Updates danach.
	3.	[ ] Frontend-Tests (optional, je nach Umfang):
	•	[ ] Rendering-Tests (z. B. mit React Testing Library).
	•	[ ] E2E-Tests (z. B. mit Cypress) für die wichtigsten Workflows (Eintrag anlegen, abschließen, PDF exportieren).

⸻

5. Projektstruktur (Beispiel)

- src
  - modules
    - etb
      - [X] etb.controller.ts        // HTTP-Controller (NestJS)
      - [X] etb.service.ts           // Business-Logik
      - dto
        - [X] create-etb.dto.ts
        - [X] update-etb.dto.ts
        - [X] filter-etb.dto.ts
        - [X] add-attachment.dto.ts
      - entities
        - [X] etb-entry.entity.ts
        - [X] etb-attachment.entity.ts
    - ...
  - main.ts
- migrations
  - [X] 1743354348523-CreateEtbTables.ts
- frontend
  - src
    - pages
      - [ ] ETBOverview.tsx
      - [ ] ETBDetail.tsx
    - components
      - [ ] ETBEntryForm.tsx
      - [ ] ...
  - ...



⸻

6. Zeitplan / Phasen
	1.	Phase 1: Datenbank & Backend-Grundlagen (2–3 Tage)
	•	[X] DB-Tabellen erstellen (Migration).
	•	[X] EinsatztagebuchService und Controller/Resolver anlegen.
	•	[X] Basis-CRUD für ETB-Einträge.
	2.	Phase 2: Frontend-Grundgerüst (2–4 Tage)
	•	[ ] ETBOverview (Liste) und ETBDetail (Detailansicht) mit Abfragen ans Backend.
	•	[ ] Formular zum Anlegen neuer Einträge.
	•	[ ] Rollen-/Rechtekonzept (mindestens clientseitige Checks).
	3.	Phase 3: Anhänge & Automatische Einträge (1–2 Tage)
	•	[X] File-Upload im Backend & Frontend implementieren.
	•	[X] Ereignis-Hooks definieren (z. B. Patientenanlage → ETB-Eintrag).
	•	[X] Validierungen und Logging.
	4.	Phase 4: Abschlusslogik & PDF-Export (1–3 Tage)
	•	[X] Schließen eines Eintrags/Einsatzes, Sperrlogik.
	•	[ ] PDF-Export (Server- oder Client-seitig).
	5.	Phase 5: Feinschliff & Tests (1–2 Tage)
	•	[ ] Integrationstests.
	•	[ ] UI-Optimierungen (Filter, Sortierung, evtl. Timeline-View).
	•	[ ] Bugfixes und Code-Review.

⸻

7. Zusammenfassung & Tipps
	•	Datenintegrität sicherstellen: Achte darauf, dass keine nachträglichen Änderungen möglich sind, sobald ein Eintrag abgeschlossen wurde.
	•	Bedienbarkeit im Einsatzumfeld: Dein Junior-Dev sollte das UI möglichst schlank gestalten (kein Overload, schnelle Eingaben).
	•	Revisionssicherheit: Eine simple Versionierung oder Änderungshistorie hilft, im Zweifel jede Bearbeitung zu rekonstruieren.
	•	Langzeitarchivierung: Dokumentiere den Export in PDF/A und die Archivierungsrichtlinien (10 Jahre Aufbewahrung).

Mit diesem Plan hat Dein Junior-Dev einen klaren roten Faden, um das Einsatztagebuch schrittweise zu realisieren. Wichtig ist regelmäßiges Feedback (Code-Reviews, Tests) und frühzeitige Integration in das Gesamtsystem (z. B. automatische Einträge). So stellst Du sicher, dass das ETB am Ende fehlerfrei und benutzerfreundlich funktioniert.