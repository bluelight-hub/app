= Übergreifende Konzepte
:author: Bluelight-Hub Team
:revnumber: 1.0.0
:revdate: 2025-03-23



== Übersicht
Dieser Abschnitt beschreibt übergreifende Konzepte und Prinzipien, die in der Architektur des Bluelight-Hub-Systems verankert sind. Diese Konzepte bilden die Grundlage für Entwurfsentscheidungen und erstrecken sich über mehrere Bausteine des Systems.

== Inhalt

=== Domänenmodell

Das Domänenmodell des Bluelight-Hub-Systems basiert auf dem "Einsatz" als zentraler Entität und den damit verbundenen Templates für wiederverwendbare Elemente. In der aktuellen Konzeption ist die Anwendung primär für die Verwaltung eines konkreten Einsatzes zuständig, wobei in den meisten Anwendungsfällen nicht mehr als ein Einsatz gleichzeitig aktiv ist.

Das grundlegende Konzept besteht darin, dass Templates für wiederverwendbare Elemente wie Personal, Fahrzeuge und Material existieren. Ein Einsatz wandelt diese Templates in konkrete Instanzen um und persistiert diese. Dadurch wird eine effiziente Erstellung und Verwaltung von Einsätzen ermöglicht, ohne jedes Mal alle Daten neu eingeben zu müssen.

[dbml]
....
// Einsatzverwaltung
Table einsatz {
  einsatzID varchar [primary key]
  bezeichnung varchar
  einsatzart_id varchar
  status varchar
  startzeit timestamp
  endzeit timestamp
}

Table einsatz_abschnitt {
  id varchar [primary key]
  einsatz_id varchar
  bezeichnung varchar
  verantwortlicher_id varchar
}

Table einsatz_art {
  code varchar [primary key]
  bezeichnung varchar
  prioritaet integer
}

// Templates
Table personal_template {
  id varchar [primary key]
  funktion varchar
  qualifikationen varchar
}

Table fahrzeug_template {
  id varchar [primary key]
  typ varchar
  kennzeichen varchar
  kapazitaet integer
}

Table material_template {
  id varchar [primary key]
  bezeichnung varchar
  kategorie varchar
}

// Ressourcenverwaltung
Table einheit {
  einheitID varchar [primary key]
  bezeichnung varchar
  typ varchar
  staerke integer
  status varchar
  einsatz_id varchar
  abschnitt_id varchar
}

Table personal {
  id varchar [primary key]
  template_id varchar
  name varchar
  status varchar
  einheit_id varchar
}

Table fahrzeug {
  id varchar [primary key]
  template_id varchar
  status varchar
  einheit_id varchar
}

Table fahrzeug_besatzung {
  fahrzeug_id varchar
  personal_id varchar
  
  indexes {
    (fahrzeug_id, personal_id) [pk]
  }
}

Table material {
  id varchar [primary key]
  template_id varchar
  anzahl integer
  status varchar
  einheit_id varchar
}

Table einsatzort {
  id varchar [primary key]
  einsatz_id varchar
  bezeichnung varchar
  lat float
  lng float
}

// Beziehungen
Ref: einsatz.einsatzart_id > einsatz_art.code
Ref: einsatz_abschnitt.einsatz_id > einsatz.einsatzID
Ref: einsatz_abschnitt.verantwortlicher_id > personal.id
Ref: einheit.einsatz_id > einsatz.einsatzID
Ref: einheit.abschnitt_id > einsatz_abschnitt.id
Ref: personal.template_id > personal_template.id
Ref: personal.einheit_id > einheit.einheitID
Ref: fahrzeug.template_id > fahrzeug_template.id
Ref: fahrzeug.einheit_id > einheit.einheitID
Ref: fahrzeug_besatzung.fahrzeug_id > fahrzeug.id
Ref: fahrzeug_besatzung.personal_id > personal.id
Ref: material.template_id > material_template.id
Ref: material.einheit_id > einheit.einheitID
Ref: einsatzort.einsatz_id > einsatz.einsatzID
....

==== Zentrale Entitäten

* *Einsatz*: Zentrale Entität, die einen konkreten Einsatzfall mit allen zugehörigen Informationen repräsentiert
* *EinsatzAbschnitt*: Unterbereich eines Einsatzes mit spezifischen Aufgaben und verantwortlichen Personen
* *Templates*: Wiederverwendbare Vorlagen für Personal, Fahrzeuge und Material
* *Instanzen*: Konkrete Ausprägungen von Templates im Kontext eines Einsatzes (Personal, Fahrzeuge, Material)
* *Einheit*: Organisatorische Einheit (z.B. Löschzug, Sanitätsgruppe), die Personal und Material umfasst

==== Beziehungen und Abhängigkeiten

* Ein Einsatz ist die zentrale Entität und kann in mehrere Einsatzabschnitte unterteilt werden
* Einsatzabschnitten können Einheiten zugeordnet werden
* Einem Einsatz sind mehrere Einheiten, Einsatzorte und eine Einsatzart zugeordnet
* Einheiten bestehen aus Personal, Fahrzeugen und Material
* Personal, Fahrzeuge und Material basieren auf Templates, die wiederverwendbare Informationen enthalten
* Bei Zuweisung zu einem Einsatz werden aus Templates konkrete Instanzen erstellt

==== Template-Konzept

Das Template-Konzept ist ein zentrales Merkmal des Domänenmodells:

* Templates dienen als wiederverwendbare Vorlagen für häufig genutzte Elemente
* Bei Einsatzerstellung werden aus Templates konkrete Instanzen erzeugt
* Änderungen an Templates wirken sich nicht rückwirkend auf bestehende Instanzen aus
* Templates ermöglichen die schnelle Konfiguration neuer Einsätze

=== Architektur- und Entwurfsmuster

==== Vereinfachte Schichtenarchitektur

Die Architektur folgt einem pragmatischen Schichtenmodell, das die Trennung von Zuständigkeiten gewährleistet, ohne unnötige Komplexität einzuführen. Statt einer vollständigen hexagonalen Architektur, die derzeit als zu komplex für die Anforderungen des Systems betrachtet wird, nutzt das System eine klare Trennung der Verantwortlichkeiten mit definierten Schichten.

[mermaid]
....
flowchart TD
    subgraph BluelightHub["Bluelight-Hub-System"]
        subgraph Praesentationsschicht["Präsentationsschicht"]
            UI["UI-Komponenten"]
            State["State Management"]
        end
        
        subgraph Anwendungsschicht["Anwendungsschicht"]
            Services["Services"]
            Controller["Controller"]
        end
        
        subgraph Datenhaltungsschicht["Datenhaltungsschicht"]
            Repositories["Repositories"]
            Datenmodelle["Datenmodelle"]
        end
    end
    
    UI --> State
    State --> Services
    Services --> Controller
    Controller --> Repositories
    Repositories --> Datenmodelle
    
    classDef presentation fill:#42A5F5,stroke:#1976D2,color:white
    classDef application fill:#66BB6A,stroke:#43A047,color:white
    classDef data fill:#FFA726,stroke:#FB8C00,color:white
    
    class UI,State presentation
    class Services,Controller application
    class Repositories,Datenmodelle data
    class Praesentationsschicht presentation
    class Anwendungsschicht application
    class Datenhaltungsschicht data
....

==== Optimierte Service-Struktur

Anstelle einer vollständigen CQRS-Implementierung, die für die aktuelle Anwendungsgröße und Komplexität als möglicherweise überdimensioniert betrachtet wird, verwendet das System eine optimierte Service-Struktur, die die Vorteile der Trennung von Lese- und Schreiboperationen bietet, ohne die Komplexität einer vollständigen CQRS-Architektur.

* *Services*: Kapseln die Geschäftslogik und Anwendungsfälle
* *Controller*: Bieten die REST-API-Schnittstellen nach außen
* *Repositories*: Abstrahieren den Datenzugriff und ermöglichen eine klare Trennung der Datenpersistenz

Diese vereinfachte Struktur ermöglicht:
* Einfachere Implementierung und Wartung
* Bessere Verständlichkeit für neue Entwickler
* Ausreichende Trennung der Zuständigkeiten
* Skalierbarkeit für die aktuelle Anwendungsgröße

==== Eventbasierte Kommunikation

Für die Kommunikation zwischen Modulen wird ein eventbasierter Ansatz verwendet:

* Klare Entkopplung der Komponenten
* Asynchrone Verarbeitung von Ereignissen
* Einfache Erweiterbarkeit durch neue Event-Handler
* Unterstützung des Verbindungskonzepts mit verschiedenen Konnektivitätsszenarien

=== Technische Konzepte

==== Verbindungskonzept

Das System ist in verschiedenen Konnektivitätsszenarien nutzbar:

* *Lokale Verbindung*: Der Client ist mit dem FüKW verbunden ("FüKW-verbunden")
* *Vollständige Verbindung*: Der FüKW ist mit dem Internet verbunden ("Online")
* *Autonomes Szenario*: Der Client hat keine Verbindung zum FüKW ("Offline")

Die aktuelle Implementierung fokussiert sich auf die ersten beiden Szenarien, wobei der lokale Verbindungsmodus die Verbindung zum FüKW beschreibt, nicht die vollständige Unabhängigkeit des Clients.

==== Testkonzept

Das Testkonzept des Bluelight-Hub-Systems adressiert die besonderen Herausforderungen einer Anwendung mit verschiedenen Verbindungsszenarien und hohen Anforderungen an Zuverlässigkeit und Benutzerfreundlichkeit.

===== Teststrategie für Verbindungsszenarien

Die Teststrategie berücksichtigt die drei Verbindungsszenarien:

* *Lokale Verbindung (FüKW-verbunden)*:
** Integration Tests für Client-FüKW-Kommunikation
** Simulation von Netzwerkbedingungen im lokalen Netzwerk
** Validierung der Datenübertragung und -synchronisation

* *Vollständige Verbindung (Online)*:
** End-to-End Tests mit externer Backend-Anbindung
** Lasttests für Skalierbarkeit und Performance
** Sicherheitstests für externe Schnittstellen

* *Autonomes Szenario (Offline)*:
** Unit Tests für lokale Datenverwaltung
** Simulation von Verbindungsabbrüchen und -wiederherstellungen
** Validierung der Datenintegritäts- und Konfliktlösungsmechanismen

===== Testbarkeit der Architektur

Die vereinfachte Schichtenarchitektur wurde mit Blick auf Testbarkeit entworfen:

* *Präsentationsschicht*:
** Komponententests für UI-Elemente
** Snapshot-Tests für visuelle Konsistenz
** Zustandstests für State Management

* *Anwendungsschicht*:
** Unit Tests für Services mit Mock-Repositories
** Integrationstests für Controller
** Verhaltensspezifikationstests für komplexe Geschäftslogik

* *Datenhaltungsschicht*:
** Unit Tests für Repository-Implementierungen
** Integrationstests mit In-Memory-Datenbank
** Persistenztests für Datenmigration und -integrität

===== Automatisierte Testprozesse

Das System nutzt mehrstufige automatisierte Testprozesse:

. *Kontinuierliche Integration*:
** Automatisierte Ausführung von Unit- und Integrationstests bei jedem Commit
** Statische Codeanalyse und Abdeckungsmessung
** Validierung der API-Kompatibilität

. *Release-Qualifikation*:
** Ausführung aller Testsuiten auf Produktionsumgebung
** Usability-Tests mit realen Nutzern
** Feldtests unter realistischen Einsatzbedingungen

===== Testdaten und -umgebungen

* *Testdaten*:
** Realistische Datensätze aus anonymisierten Einsatzszenarien
** Grenzfall-Testdaten für Extremsituationen
** Generierte Massendaten für Performancetests

===== Spezielle Testfokusgebiete

* *Synchronisationstests*:
** Validierung der Datensynchronisation zwischen Client und FüKW
** Behandlung von Konflikten bei gleichzeitigen Änderungen
** Wiederherstellung nach Verbindungsabbrüchen

* *Degradationstests*:
** Überprüfung der eingeschränkten Funktionalität bei Verbindungsverlust
** Validierung der Benutzerbenachrichtigungen und -führung
** Funktionsumfang in verschiedenen Verbindungsszenarien

* *Usability-Tests*:
** Benutzerfreundlichkeit in Stresssituationen
** Zugänglichkeit und Bedienbarkeit
** Effektivität unter realistischen Einsatzbedingungen

Diese umfassende Teststrategie stellt sicher, dass das Bluelight-Hub-System unter allen Einsatzbedingungen zuverlässig und effektiv funktioniert und die hohen Anforderungen an Qualität und Benutzerfreundlichkeit erfüllt.

==== Daten-Synchronisation

[mermaid]
....
sequenceDiagram
    participant Mobile as Mobile Client
    participant Server as FüKW-Server
    participant Other as Anderer Client

    Mobile->>Mobile: Lokale Änderung
    Mobile->>Mobile: Speichere Änderung + Timestamp
    
    alt Bei bestehender Verbindung
        Mobile->>Server: Sende Änderung
        Server->>Server: Validiere & Speichere
        Server->>Other: Propagiere Änderung
    else Bei Offline-Modus
        Mobile->>Mobile: Markiere zur Synchronisation
    end
    
    Note over Mobile,Server: Spätere Verbindungswiederherstellung
    
    Mobile->>Server: Sende ausstehende Änderungen
    Server->>Mobile: Sende verpasste Änderungen
    
    alt Bei Konflikt
        Server->>Server: Identifiziere Konflikt
        Server->>Mobile: Konfliktinformation
        Mobile->>Mobile: Zeige Konfliktlösung-UI
        Mobile->>Server: Sende aufgelösten Konflikt
    end
....

* Konfliktauflösung basierend auf Timestamps und Domänenregeln
* Selektive Synchronisation nach Priorität der Daten
* Bidirektionaler Synch-Mechanismus zwischen FüKW-Server und Mobilgeräten

==== Security-Konzept

* *Authentifizierung*: Rollenbasiertes Zugriffsmodell mit verschiedenen Berechtigungsstufen
* *Datenschutz*: Verschlüsselung sensibler Daten in Rest und während der Übertragung
* *Auditierung*: Logging aller sicherheitsrelevanten Ereignisse für spätere Analyse

==== Fehlerbehandlung und Resilience

* Graceful Degradation bei Teilausfällen
* Circuit Breaker Pattern für externe Integrationen
* Automatische Wiederherstellung nach Systemfehlern

=== UI-Konzepte

==== Responsive Design

* Adaptives Layout für verschiedene Bildschirmgrößen
* Touch-optimierte Bedienung für Tablet-Nutzung im Einsatz
* Barrierefreiheit für verschiedene Nutzergruppen

==== Dashboard-Ansichten

Das Bluelight-Hub-System nutzt spezialisierte Dashboard-Ansichten für die Visualisierung und das Monitoring wichtiger Einsatzdaten:

* Separate Webview-Fenster für fokussierte Darstellung
* Optimiert für Multi-Monitor-Setups im Einsatzumfeld
* Automatische Datenaktualisierung mit konfigurierbaren Intervallen
* Statistische Übersichten und detaillierte Echtzeit-Informationen
* Klare visuelle Hierarchie für schnelle Informationserfassung

[mermaid]
....
flowchart TD
    MainApp[Hauptanwendung] --> |öffnet| WebView[Dashboard Webview]
    WebView --> |zeigt| DashboardLayout[Dashboard Layout]
    DashboardLayout --> |enthält| Stats[Statistiken]
    DashboardLayout --> |enthält| Tables[Tabellen/Listen]
    DashboardLayout --> |enthält| RefreshMech[Aktualisierungsmechanismus]
    
    classDef main fill:#42A5F5,stroke:#1976D2,color:white
    classDef view fill:#66BB6A,stroke:#43A047,color:white
    classDef comp fill:#FFA726,stroke:#FB8C00,color:white
    
    class MainApp main
    class WebView,DashboardLayout view
    class Stats,Tables,RefreshMech comp
....

Die Dashboard-Architektur nutzt Tauri Webviews für leichtgewichtige, separate Fenster, die dennoch eng mit der Hauptanwendung integriert sind. Die vollständige Begründung und technische Details sind in <<../adr/009-dashboard-architektur.adoc>> dokumentiert.

==== Kontextbezogene Benutzeroberfläche

* Anpassung der UI basierend auf Einsatzrolle und -phase
* Priorisierung relevanter Informationen im aktuellen Kontext
* Reduktion kognitiver Belastung durch fokussierte Ansichten

=== Persistenzkonzept

* SQLite als lokale Datenbank auf allen Endgeräten
* Versionierung von Datensätzen für Konfliktauflösung
* Inkrementelle Backups auf FüKW-Server

=== Integrations- und Schnittstellenkonzept

* RESTful APIs für synchrone Kommunikation
* WebSockets für Echtzeitkommunikation
* Standardisierte Schnittstellen zu Leitstellen-Systemen
* Adapter für Digitalfunk-Integration

=== NestJS Backend-Architekturkonzepte

==== Übersicht und Prinzipien

Das Backend des Bluelight-Hub-Systems basiert auf dem NestJS-Framework und folgt der modularen Architektur, die dieses Framework vorgibt. NestJS wurde gewählt, da es eine strukturierte, modulare und gut skalierbare Codebasis ermöglicht, die auf bewährten Konzepten wie Dependency Injection, AOP (Aspect-Oriented Programming) und dem SOLID-Prinzip basiert.

Die Hauptprinzipien unserer Backend-Architektur sind:

1. **Domänenorientierte Modularisierung**: Organisation des Codes nach Geschäftsdomänen statt nach technischen Aspekten
2. **Klare Schichtenarchitektur**: Trennung von Kontrollebene (Controller), Geschäftslogik (Services) und Datenzugriff (Repositories)
3. **Dependency Injection**: Verwendung des integrieren DI-Containers für lose Kopplung und verbesserte Testbarkeit
4. **Consistent Error Handling**: Einheitliche Fehlerbehandlung durch Exception Filter
5. **Typed Interfaces**: Konsequente Nutzung von TypeScript für Typsicherheit auf allen Ebenen
6. **Cross-Cutting Concerns Separation**: Aspekte wie Logging, Validierung und Auth in spezialisierten Komponenten

==== Modulare Struktur

Die Backend-Codebasis ist in `packages/backend` organisiert und folgt dieser grundlegenden Struktur:

[source]
----
packages/backend/
├── common/           # Querschnittskomponenten
│   ├── decorators/   # Custom-Decorators
│   ├── filters/      # Exception Filter
│   ├── guards/       # Auth Guards
│   ├── interceptors/ # Interceptors
│   └── pipes/        # Validierungs-Pipes
├── config/           # Konfigurationen
└── modules/          # Fachliche Module
    ├── auth/         # Authentifizierungsmodul
    ├── einsatz/      # Einsatzmodul
    └── ...           # Weitere Fachmodule
----

Jedes Fachmodul ist nach dieser Struktur organisiert:

[source]
----
modules/module-name/
├── controllers/      # API-Endpoints
├── services/         # Geschäftslogik
├── repositories/     # Datenzugriff
├── entities/         # Datenbankmodelle
├── dto/              # Data Transfer Objects
├── interfaces/       # TypeScript-Interfaces
├── enums/            # Enumerationen
├── constants/        # Konstanten
├── utils/            # Hilfsfunktionen
└── __tests__/        # Tests
----

==== Architekturmuster und Pattern

===== Domain-Driven Design (DDD)

Die Backend-Architektur orientiert sich an DDD-Prinzipien:

* **Bounded Contexts**: Module repräsentieren abgegrenzte Fachdomänen
* **Entities**: Objekte mit Identität über ihren Lebenszyklus
* **Value Objects**: Unveränderliche Objekte ohne eigene Identität
* **Domain Services**: Komplexe Geschäftslogik, die nicht zu einer einzelnen Entität gehört
* **Repositories**: Abstraktion des Datenzugriffs

===== CQRS-Grundsätze

Für komplexere Domänen kann das CQRS-Muster (Command Query Responsibility Segregation) angewendet werden:

* **Queries**: Leseoperationen werden in spezialisierten Query-Handlern implementiert
* **Commands**: Schreiboperationen werden in Command-Handlern gekapselt
* **Events**: Domänen-Events signalisieren wichtige Änderungen

===== Repository Pattern

Das Repository-Pattern abstrahiert den Datenbankzugriff:

* **Generische Repositories**: Für gemeinsame CRUD-Operationen
* **Domänenspezifische Repositories**: Für komplexe Abfragen
* **Typsicherheit**: TypeORM-Integration mit vollständiger TypeScript-Unterstützung

===== Dependency Injection

NestJS bietet einen leistungsfähigen DI-Container:

* **Constructor Injection**: Dependencies werden im Konstruktor injiziert
* **Provider System**: Services, Repositories und andere Komponenten als Provider
* **Scopes**: Singleton (Standard), Request-scoped oder Transient Instanzen
* **Custom Providers**: Factory-Provider für komplexe Instanziierung

==== Komponententypen

Die Backend-Architektur umfasst folgende Hauptkomponententypen:

[cols="1,3,2", options="header"]
|===
|Komponente |Verantwortlichkeit |Pattern/Prinzip
|Controller |Definieren der HTTP-Endpunkte und Routing |MVC Controller
|Service |Implementierung der Geschäftslogik |Domain Service
|Repository |Datenbankoperationen und Abfragen |Repository Pattern
|Entity |Datenbankmodelle und Beziehungen |Domain Entity
|DTO |Datenstrukturen für API-Kommunikation |Data Transfer Object
|Module |Komponenten-Bündelung und -Organisation |Modul Pattern
|Guard |Zugriffskontrolle und Autorisierung |Intercepting Filter
|Interceptor |Request/Response-Transformation |AOP/Decorator
|Pipe |Eingabevalidierung und -transformation |Filter/Interceptor
|Filter |Fehlerbehandlung und -formatierung |Exception Handler
|Decorator |Metaprogrammierung und Annotationen |Decorator Pattern
|===

==== Architekturentscheidungen

Bei der Entwicklung des Backends wurden folgende Architekturentscheidungen getroffen:

1. **Monolithische Struktur mit modularer Organisation**: Trotz der Unterteilung in Module wird das Backend als Monolith deployed, aber mit klarer Trennung zwischen den Modulen für mögliche spätere Extraktion.

2. **Shared Types mit Frontend**: DTOs und Entitäten werden durch OpenAPI/Swagger-Generierung mit dem Frontend geteilt, um Typkonsistenz zu gewährleisten.

3. **SQLite als Primärdatenbank**: Verwendung von SQLite für einfache Bereitstellung und lokale Entwicklung mit der Möglichkeit, später auf andere RDBMS umzusteigen.

4. **Repository Pattern über Active Record**: Bewusste Entscheidung für das Repository-Pattern statt Active Record für bessere Testbarkeit und Abstraktion.

5. **Einheitliche Fehlerbehandlung**: Globale Exception Filter für konsistente API-Fehlerantworten.

==== API-Design

Das API-Design folgt den REST-Prinzipien mit folgenden Merkmalen:

* **Ressourcenorientiert**: Endpunkte repräsentieren Ressourcen, nicht Aktionen
* **HTTP-Verben**: Verwendung von GET, POST, PUT, DELETE für CRUD-Operationen
* **Versionierung**: API-Versionen durch URI-Pfad (/api/v1/resource)
* **Dokumentation**: OpenAPI/Swagger-Dokumentation für alle Endpunkte
* **Validierung**: DTO-basierte Eingabevalidierung mit class-validator
* **Fehlerformate**: Einheitliches Fehlerformat mit HTTP-Statuscodes

==== Querschnittskonzepte

Folgende Querschnittskonzepte ziehen sich durch die gesamte Backend-Architektur:

* **Logging**: Strukturiertes Logging mit dem consola-Logger
* **Authentifizierung**: JWT-basierte Authentifizierung mit Guards
* **Autorisierung**: Rollenbasierte Zugriffssteuerung mit Guards und Decorators
* **Validierung**: DTO-basierte Validierung mit ValidationPipe
* **Fehlerbehandlung**: Globale Exception Filter für einheitliche Fehlerantworten
* **Konfigurationsmanagement**: Umgebungsspezifische Konfiguration mit ConfigService

Diese Architekturkonzepte bilden das Fundament für ein wartbares, erweiterbares und robustes Backend-System, das kontinuierlich weiterentwickelt werden kann.

== Offene Punkte und Entscheidungen

* Detaillierte Spezifikation der Konfliktlösungsstrategien bei Daten-Synchronisation
* Definition von Performance-Benchmarks für Offline-Operationen
* Auswahl spezifischer Verschlüsselungsstandards für sensible Daten

[mermaid]
....
flowchart TD
    ConnectionCheck{Verbindung?}
    ConnectionCheck -->|Verbunden zum FüKW| LOCAL[Lokale Verbindung]
    ConnectionCheck -->|Keine Verbindung| OFFLINE[Autonomer Offline-Modus]
    LOCAL --> InternetCheck{Internet verfügbar?}
    InternetCheck -->|Ja| ONLINE[Online-Modus mit erweiterten Funktionen]
    InternetCheck -->|Nein| LOCALONLY[Nur lokale FüKW-Funktionalität]
....

[mermaid]
....
graph TD
    A[Client App] --> B{Verbindungszustand?}
    B -->|FüKW-verbunden| C[Lokale Verbindung]
    B -->|Online| D[Vollständige Verbindung]
    B -->|Offline| E[Autonomer Modus]
    
    C --> F[Vollständige lokale Funktionalität]
    D --> G[Erweiterte Funktionen]
    E --> H[Eingeschränkte Funktionalität]
    
    C -.-> I[Synchronisation nur mit lokalen Clients]
    D -.-> J[Volle Synchronisation]
    E -.-> K[Lokales Speichern, spätere Sync]
    
    style C fill:#B3E5FC,stroke:#0288D1
    style D fill:#BBDEFB,stroke:#1976D2
    style E fill:#FFECB3,stroke:#FF8C00
....