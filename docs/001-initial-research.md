# Planung und Architektur für "Bluelight Hub"

Die Anwendung **Bluelight Hub** soll Einsätze im Katastrophenschutz (insbesondere für den DRK-Einsatzleitwagen) digital unterstützen. Nachfolgend sind die Kernpunkte der Planung und Architektur aufgeführt – von der technologischen Grundlage über Module/Funktionen bis hin zur Roadmap. Ziel ist eine moderne, **offline-fähige** Einsatzführungssoftware, die intuitiv bedienbar ist und bewährte Funktionen ähnlicher Systeme (z.B. Fireboard) übernimmt und verbessert.

## 1. Technologische Anforderungen

- **Frontend (Desktop & Mobil):** Die Hauptanwendung wird als **Tauri**-App entwickelt. Tauri erlaubt es, mit Web-Technologien (HTML/CSS/JS) eine native Desktop-Anwendung für Windows/Linux zu bauen, ist leichtgewichtig und performant ([Electron | Marcin Skrzyński's Blog](https://marcin.codes/tags/Electron/#:~:text=Tauri%20is%20a%20framework%20for,it%20with%20NodeJS%20server%20aside)). Die UI wird responsiv gestaltet, sodass sie auch via Browser oder auf Tablets/Smartphones nutzbar ist (z.B. als Progressive Web App). Für hohe Usability sorgen moderne Web-Frameworks (etwa React, Vue oder Angular) und ein übersichtliches Design. *Vorteil:* Tauri bietet ähnlich wie Electron plattformübergreifende Builds, aber mit kleinerem Footprint – dank Rust-Core und Nutzung der systemeigenen WebEngine ([Electron | Marcin Skrzyński's Blog](https://marcin.codes/tags/Electron/#:~:text=Tauri%20is%20a%20framework%20for,it%20with%20NodeJS%20server%20aside)). Eine Web-Variante erlaubt optional den Zugriff im Browser im ELW-Netz oder online.

- **Backend:** Im Hintergrund läuft ein **Node.js** Server basierend auf **NestJS**. NestJS ist ein progressives Node-Framework mit **modularer Architektur**, das eine saubere Trennung nach Features erlaubt ([Mastering Nest.js: Building Scalable Node.js Applications Made Easy - DEV Community](https://dev.to/chintanonweb/mastering-nestjs-building-scalable-nodejs-applications-made-easy-p3c#:~:text=,Modular%20Architecture)). Dies macht den Server gut skalierbar und wartbar, da jedes Modul (z.B. ETB, Patienten) als eigenständiger NestJS-Module implementiert wird. NestJS nutzt TypeScript und unterstützt von Haus aus **Dependency Injection** sowie die Einbindung von **WebSockets** und Microservices ([Mastering Nest.js: Building Scalable Node.js Applications Made Easy - DEV Community](https://dev.to/chintanonweb/mastering-nestjs-building-scalable-nodejs-applications-made-easy-p3c#:~:text=With%20its%20modular%20architecture%20and,microservices%2C%20enabling%20developers%20to%20handle)) – ideal für Echtzeit-Updates im Einsatz. Der Backend-Server kann lokal auf dem ELW-Rechner laufen (für **Offline-Betrieb**) und stellt eine API für die Frontends bereit. Optional kann ein Cloud-Backend mit identischer API-Struktur bereitgestellt werden, um bei Internetverbindung eine Synchronisation zu ermöglichen.

- **Datenhaltung:** Primär wird lokal eine **Datenbank** genutzt, um alle Einsatzdaten offline vorzuhalten. Hier bietet sich eine dateibasierte DB wie **SQLite** an, die ohne Server auskommt und zuverlässig auf dem lokalen Rechner läuft. Alternativ ist auch eine NoSQL-Lösung wie **NeDB** oder ein embedded JSON-Store denkbar für das MVP, jedoch liefert SQLite mehr Stabilität und kann bei Bedarf mit ORMs (TypeORM/Prisma) in NestJS integriert werden. Die Anwendung folgt einem **Offline-First**-Ansatz – d.h. sie funktioniert vollständig ohne Internet und synchronisiert Daten bei Bedarf später ([Local First / Offline First | RxDB - JavaScript Database](https://rxdb.info/offline-first.html#:~:text=Local,server%2C%20the%20gateway%20for%20all)). Die lokale DB ist die führende Datenquelle; wenn Konnektivität besteht, werden Änderungen asynchron an den zentralen Server übertragen ([Local First / Offline First | RxDB - JavaScript Database](https://rxdb.info/offline-first.html#:~:text=Local,server%2C%20the%20gateway%20for%20all)). Größere Dateien oder Berichte können optional extern gespeichert werden: z.B. Upload von PDF-Berichten in einen **S3**-Bucket. Das Ablegen von Berichten/Logs auf Amazon S3 ermöglicht es, umfangreiche Einsatzdokumentationen zentral und ausfallsicher zu archivieren ([Store Reports and Logs on S3—JVM Cluster · digital.ai Release](https://docs.digital.ai/release/docs/how-to/store-report-and-logs-s3-jvm#:~:text=You%20can%20configure%20Digital,your%20existing%20data%20if%20necessary)), ohne den lokalen Speicher zu belasten. 

- **Kommunikation & Netzwerk:** Die Architektur sieht eine **lokale Server-Client-Struktur** vor. Der NestJS-Server auf dem ELW agiert als **Host im Fahrzeugnetz** (z.B. WLAN im Einsatzleitwagen); sämtliche Clients (z.B. weitere Laptops, Tablets) verbinden sich über dieses lokale Netz. Dies garantiert Unabhängigkeit vom Internet – ein **Fahrzeug-First-Betrieb**, bei dem alle wichtigen Funktionen offline verfügbar sind ([NEUE BROSCHÜRE](https://rescuetablet.de/documents/rescueTABLET_Datenblatt.pdf#:~:text=Alle%20Funktionen%20%26%20Module%20von,in%20einer%20Anwendung%20zur%20Verf%C3%BCgung)). Für die Synchronisation in Echtzeit zwischen mehreren Clients im Fahrzeug wird auf Web-Technologien gesetzt: Der Server stellt REST-API **und WebSocket**-Endpoints bereit. WebSockets ermöglichen es, z.B. neue Einträge im Einsatztagebuch oder Positionsänderungen auf der Karte sofort an alle verbundenen Geräte zu verteilen. NestJS integriert WebSocket-Support nahtlos ([Mastering Nest.js: Building Scalable Node.js Applications Made Easy - DEV Community](https://dev.to/chintanonweb/mastering-nestjs-building-scalable-nodejs-applications-made-easy-p3c#:~:text=With%20its%20modular%20architecture%20and,microservices%2C%20enabling%20developers%20to%20handle)), was für die Multi-Client-Fähigkeit genutzt wird. Sollte Internet bestehen, kann der ELW-Server sich optional mit einer Cloud synchronisieren (Pull/Push der Änderungen). Die Online-Synchronisation erfolgt über sichere HTTPS-Verbindungen an ein zentrales Backend (ebenfalls NestJS) – so können Lagebilder an eine Leitstelle oder andere Fahrzeuge übertragen werden. Dank **Offline-First-Design** kann Bluelight Hub jedoch auch längere Zeit autonom im Feld laufen und später konsolidieren ([Offline and Thriving: Building Resilient Applications with Local-First Techniques - InfoQ](https://www.infoq.com/presentations/offline-first-apps/#:~:text=came%20up%20with,first%20technology)).

- **Sicherheit:** Es wird eine einfache, aber robuste Zugriffskontrolle implementiert. Im lokalen Betrieb genügt eine **Benutzernamen/Passwort**-Verwaltung, um z.B. festzuhalten, welcher ELW-Mitarbeiter welche Aktion protokolliert. Bei Verbindung mit dem Online-Backend kommen **Access Tokens** zum Einsatz: Nach dem Login erhält der Client ein JWT-Token, das bei API-Requests mitgeschickt wird ([Authentication | NestJS - A progressive Node.js framework](https://docs.nestjs.com/security/authentication#:~:text=Let%27s%20flesh%20out%20our%20requirements,that%20contain%20a%20valid%20JWT)). Nur Anfragen mit gültigem Token können die Cloud-API nutzen, was unautorisierten Zugriff verhindert. Die Datenübertragung online erfolgt über TLS-Verschlüsselung. Lokal im geschützten ELW-Netz kann der Traffic unverschlüsselt bleiben (für geringere Latenz), optional lässt sich aber auch hier Verschlüsselung aktivieren, falls erforderlich. Sensible Daten (z.B. Patientendaten) werden vor einer Cloud-Synchronisation verschlüsselt gespeichert oder nur in anonymisierter Form übertragen, um Datenschutz zu gewährleisten. Außerdem werden regelmäßige **Backups** der lokalen DB empfohlen (z.B. beim Herunterfahren des Systems ein Export, der ebenfalls auf USB oder S3 gesichert wird). 

## 2. Module & Funktionen

Bluelight Hub wird in **mehrere Module** unterteilt, die die wichtigsten Aufgabengebiete im Einsatz abdecken. Jedes Modul stellt eine bestimmte Funktionalitätsgruppe dar, orientiert an bewährten Lösungen aus dem BOS-Bereich (z.B. dem Funktionsumfang von Fireboard ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Fireboard%20bietet%20Ihnen%20eine%20umfassende,bis%20hin%20zur%20vollst%C3%A4ndigen%20Berichterstattung))). Kernmodule und ihre Funktionen sind:

- **Einsatz-Tagebuch (ETB):** Zentrales **Einsatztagebuch** zur chronologischen Protokollierung aller Ereignisse, Meldungen und Maßnahmen. Nutzer können Einträge mit Zeitstempel erfassen (z.B. “12:30 Uhr - Lageerkundung durch Trupp A abgeschlossen”), kategorisieren und bei Bedarf priorisieren. Das ETB-Modul ermöglicht das Anhängen von Dateien (Fotos, Dokumente) an Log-Einträge und die Zuweisung von Verantwortlichen. Ähnlich wie in Fireboard gehört ein ETB zu den Grundfunktionen ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Das%20Fireboard%20Grundsystem%20erm%C3%B6glicht%20Ihnen,von%20der%20FEZ%20verfolgt%20werden)) und bildet die Grundlage der Einsatzdokumentation. Über einen **Echtzeit-Ticker** werden neue Logeinträge an alle verbundenen Arbeitsplätze verteilt (vergleichbar mit dem FEZ-Ticker bei Fireboard ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Das%20Fireboard%20Grundsystem%20erm%C3%B6glicht%20Ihnen,von%20der%20FEZ%20verfolgt%20werden))), damit jeder im Team den gleichen Informationsstand hat. Filter- und Suchfunktionen erleichtern das Finden von Einträgen während längerer Lagen.

- **Lagekarte:** Ein Kartenmodul zur **darstellerischen Lageführung**. Auf einer **interaktiven Karte** (OpenStreetMap-Basis) können Einsatzorte, Bereiche und Ressourcen verortet werden. Das Modul unterstützt das Setzen von Markern mit **taktischen Zeichen** (z.B. Symbole für Sammelstellen, Einsatzleitung, Gefahrenpunkte), das Zeichnen von Polygone/Lines (Absperrbereiche, Suchgebiete) und das Anzeigen von Zusatzinfos (z.B. Windrichtung, was bei Gefahrstofflagen wichtig sein kann ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20dem%20Modul%20Lagekarte%20l%C3%A4sst,Informationen%20f%C3%BCr%20taktische%20Entscheidungen%20liefert))). Die Karte bietet Zoom/Schwenk-Funktionen, ist offline nutzbar (durch vorheriges Laden oder Speichern der Kacheln) und kann verschiedene Layer darstellen (Straßenkarte, Satellit, Einsatz-Skizzen). **Einsatzabschnitte** können visuell abgegrenzt und beschriftet werden. Dieses Modul soll dem ELW-Team ein aktuelles Lagebild vermitteln ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20dem%20Modul%20Lagekarte%20l%C3%A4sst,Informationen%20f%C3%BCr%20taktische%20Entscheidungen%20liefert)) – ähnlich dem Fireboard-Lagekartensystem, das durch Einzeichnen aller relevanten Elemente eine fundierte taktische Entscheidungsgrundlage liefert ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20dem%20Modul%20Lagekarte%20l%C3%A4sst,Informationen%20f%C3%BCr%20taktische%20Entscheidungen%20liefert)). Zudem können Live-Daten, sofern verfügbar (z.B. GPS-Positionen von Fahrzeugen), eingeblendet werden. Eine Besonderheit ist die Unterstützung von **Offline-Karten**: Durch Integration von Leaflet o.ä. mit lokal gespeicherten OSM-Kacheln oder Vektordaten kann die Karte ohne Internet genutzt werden ([Microsoft Word - Y4710](https://www.atlantis-press.com/article/25839801.pdf#:~:text=on%20OSM%20,the%20security%20of%20the%20system)). Geplante Features sind auch eine **Hydranten- und Infrastrukturkarte** (vorausgesetzt passende Daten sind vorab importiert) und ggf. die Einbindung externer Kartenlayer (wie Rettungskarten oder Gefahrenstoffe, ähnlich rescueTABLET ([NEUE BROSCHÜRE](https://rescuetablet.de/documents/rescueTABLET_Datenblatt.pdf#:~:text=einsatzentscheidenden%20Informationen%20f%C3%BCr%20Feuerwehren%20und,alle%20einsatz%02relevanten%20Informationen%20digital%20und))).

- **Patientenverwaltung:** Modul zur **Erfassung und Verwaltung von Patienten** bei Sanitätsdiensten oder MANV-Lagen (Massenanfall von Verletzten). Hier können Einsatzkräfte Patienten anlegen mit einer **Patientennummer**, Status (unverletzt/verletzt, Triage-Kategorie), persönlichen Daten (sofern bekannt) und Befunden. Es ist möglich, **Sichtungsergebnisse (Triage)** und durchgeführte **Behandlungen** je Patient zu dokumentieren ([Modul Sanitätsdienst - Fireboard](https://fireboard.net/produkte/module/modul-sanitaetsdienst/#:~:text=Schnelle%20Patientenerfassung)). Die Patientenverwaltung bietet eine Übersichtsliste aller Patienten mit Filter (z.B. nach Behandlungsstatus oder Transportpriorität). Zudem können **Transportentscheidungen** festgehalten werden: z.B. Patient X wurde um 13:05 mit RTW 5 in Klinik Y transportiert. Aus Datenschutzgründen kann eine Außenansicht genutzt werden, die nur anonymisierte Infos zeigt (etwa dass N Patienten Kategorie Rot transportbereit sind) ([Modul Sanitätsdienst - Fireboard](https://fireboard.net/produkte/module/modul-sanitaetsdienst/#:~:text=Schnelle%20Patientenerfassung)) – analog zur in Fireboard erwähnten anonymen Transportübersicht ([Modul Sanitätsdienst - Fireboard](https://fireboard.net/produkte/module/modul-sanitaetsdienst/#:~:text=Schnelle%20Patientenerfassung)). Dieses Modul entlastet den Dokumentationsteil auf Papier (z.B. Patienten-AUF) und erlaubt im Nachgang eine saubere **Abrechnung und Nachverfolgung** der Versorgten. In Vorfällen mit vielen Betroffenen (Evakuierungen etc.) behält man so den Überblick ([Modul Sanitätsdienst - Fireboard](https://fireboard.net/produkte/module/modul-sanitaetsdienst/#:~:text=Das%20Modul%20%E2%80%9ESanit%C3%A4tsdienst%E2%80%9C%20hilft%20Ihnen%2C,Einblick%20in%20die%20Lage%20vermitteln)) ([Modul Sanitätsdienst - Fireboard](https://fireboard.net/produkte/module/modul-sanitaetsdienst/#:~:text=Sie%20erfassen%20mit%20der%20Patientenaufnahme,in%20den%20Patientendaten%20dokumentiert%20werden)).

- **Fahrzeug- und Kräfteverwaltung:** Modul für die **Übersicht über alle Einsatzfahrzeuge und Einsatzkräfte**. Hier werden alle im Einsatz befindlichen Fahrzeuge (z.B. RTW, KTW, ELW, GW-San) mit Funkrufnamen erfasst. Für jedes Fahrzeug kann der **Status** (1 = Einsatzbereit, 3 = Auf Anfahrt, 4 = Am Einsatzort, etc.) hinterlegt und geändert werden – so sieht die Einsatzleitung jederzeit, welche Fahrzeuge verfügbar sind (ähnlich der Einsatzmittelstatus-Anzeige in Fireboard ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=%5BImage%208%3A%20Fireboard%20,und%20Mittel%C3%BCbersicht))). Darüber hinaus können Fahrzeuge bestimmten **Einsatzabschnitten** oder Standorten zugewiesen werden, was insbesondere in größeren Lagen wichtig ist ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20Hilfe%20des%20Moduls%20Einsatzf%C3%BChrung,auf%20die%20einzelnen%20Abschnitte%20verteilt)). Das Modul zeigt eine **Kräfteübersicht** an: welche Mannschaftsstärke ist in jedem Abschnitt vorhanden, welche Trupps sind eingeteilt ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20Hilfe%20des%20Moduls%20Einsatzf%C3%BChrung,auf%20die%20einzelnen%20Abschnitte%20verteilt)). Funktionen: Zuweisen/Abmelden von Fahrzeugen, Personalstärken eintragen, ggf. Namen der Gruppenführer vermerken. Diese Komponente lehnt sich an Fireboard’s Modul *Einsatzführung* an, das die Zuordnung von Fahrzeugen zu Abschnitten und das Abbilden der Führungsstruktur erlaubt ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Einsatzf%C3%BChrung)). Dadurch weiß man stets, *wer* wo im Einsatz tätig ist und kann **Ressourcen gezielt nachführen**. Perspektivisch könnte hier auch eine **Personalverwaltung** integriert werden, um einzelne Helfer mit Qualifikation zu erfassen (ähnlich HiOrg-Server im Vorfeld, jedoch hier fokussiert auf die aktuelle Lage).

- **Kommunikation (Nachrichtenmodul):** Dieses Modul dient zur **Dokumentation und Verwaltung von Nachrichten** und Meldungen, etwa Funk- oder Telefonverkehr. Einsatzleitende können eingehende Meldungen (z.B. von der Leitstelle oder anderen Einheiten) als **Nachricht** erfassen, mit Zeit, Absender, Empfänger und Inhalt. Alle Nachrichten werden geloggt und können kategorisiert werden (z.B. „Statusmeldung“, „Anforderung“, „Lageänderung“). Wichtig ist eine Möglichkeit, Nachrichten als **erledigt/quittiert** zu markieren ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Kommunikation)), damit nichts untergeht. Ebenso kann eine Nachricht mit einer Notiz oder Antwort versehen werden ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Kommunikation)). Dieses Modul strukturiert die Führungscommunication, vergleichbar mit dem Kommunikationsmodul von Fireboard ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Kommunikation)) oder einem klassischen Funktagebuch. Zusätzlich könnten Schnittstellen implementiert werden, um SMS/Email oder Messengerdienste (sofern im Einsatz genutzt) hier mit einzuspeisen. Auch Vorlagen für typische Meldungen (Lagemeldung, Nachforderung) erleichtern die Arbeit. Langfristig ist denkbar, Funkgeräte (TETRA) anzubinden, um Statusmeldungen automatisch zu empfangen.

- **Aufgaben- / Auftragsverwaltung:** Im Einsatz entstehen oft viele **Aufträge und Aufgaben**, die verteilt und nachverfolgt werden müssen – z.B. “Sammelplatz aufbauen”, “Bereitstellungsraum XY besetzen”, “Verpflegung anfordern”. Dieses Modul erlaubt es, **Aufgaben anzulegen**, einem Verantwortlichen oder Abschnitt zuzuweisen und den Fortschritt zu tracken. Ähnlich dem Fireboard-Modul *Ausnahmezustand* (für Lagen mit vielen parallelen Aufträgen) können offene Aufgaben gelistet, priorisiert und als *erledigt* markiert werden ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Ausnahmezustand)). Die Einsatzleitung behält so den Überblick, welche Maßnahmen noch laufen oder offen sind. Jede Aufgabe enthält Beschreibung, Zeitstempel (Anlage, Deadline) und Verantwortliche. Der aktuelle Status (offen/in Bearbeitung/erledigt) wird angezeigt ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Modul%20Ausnahmezustand)). Diese Funktion verbessert die Struktur in Chaossituationen erheblich, da nichts vergessen wird und jeder weiß, wer woran arbeitet.

- **Weitere Module (optional):** Basierend auf etablierten Lösungen können weitere sinnvolle Module ergänzt werden:
  - **Lagedokumentation & Berichte:** Die Möglichkeit, wichtige Dokumente zu generieren, etwa eine **Lagemeldung** oder einen Abschlussbericht auf Knopfdruck. Das System kann aus ETB und Moduldaten automatisch **Berichts-PDFs** erstellen (Einsatztagebuch-Auszug, Patientenlisten, etc.), die ggf. auch direkt ins S3-Archiv geladen werden. Fireboard beispielsweise deckt den Prozess von Alarmierung bis zur **vollständigen Berichterstattung** digital ab ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Fireboard%20bietet%20Ihnen%20eine%20umfassende,bis%20hin%20zur%20vollst%C3%A4ndigen%20Berichterstattung)) – Bluelight Hub soll dies ebenfalls ermöglichen, um den Papierkram im Nachgang zu reduzieren.
  - **Alarmdaten-Import:** Falls eine Anbindung an die Leitstellensoftware möglich ist, könnte ein Modul die **Übernahme von Alarmierungsdaten** bieten (wie in Fireboard vorgesehen ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=%5BImage%2019%3A%20Fireboard%20))). So werden initiale Einsatzinfos (Einsatznummer, Stichwort, Adresse, alarmierte Einheiten) automatisch eingetragen.
  - **Vorlagen & Checklisten:** Verwaltung von **Einsatzvorlagen** (z.B. vordefinierte Ablaufpläne für bestimmte Szenarien) und Checklisten (z.B. Fahrzeug-Checkliste bei Abfahrt, Führungshausaufgaben) zur Unterstützung der Einsatzkräfte. Fireboard bietet Einsatzvorlagen als Modul ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=)); eine ähnliche Funktion in Bluelight Hub könnte die Vorbereitung auf Standardlagen erleichtern.
  - **Spezialmodule:** Je nach Bedarf der Organisation könnten weitere Module integriert werden, z.B. **Atemschutzüberwachung** (für Feuerwehren relevant, Überwachung von Atemschutztrupps nach FwDV7, ähnlich Fireboard’s Modul ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=%5BImage%2029%3A%20Fireboard%20))) oder **CBRN-Lage** (Erfassung besonderer Gefahrstoff-Ereignisse). Diese wären jedoch beim DRK weniger prioritär und könnten als Plugins später folgen.

Alle Module greifen nahtlos ineinander, um **Doppelarbeit zu vermeiden**. Änderungen in einem Modul können ggf. andere aktualisieren (z.B. Zuweisung eines Patienten in einen Krankenwagen spiegelt sich in Fahrzeug- und Patientenmodul wider). Durch die modulare Architektur von NestJS können einzelne Module bei Bedarf hinzugefügt oder weggelassen werden, je nach Einsatzanforderung.

## 3. Vergleich mit bestehenden Lösungen

Bei der Konzeption von Bluelight Hub lohnt ein Blick auf bestehende Software im BOS-Bereich, um bewährte Funktionen zu übernehmen und Schwachstellen zu vermeiden. **Fireboard** ist ein prominentes Beispiel einer Einsatzführungssoftware für Feuerwehr und Rettungsdienst. Fireboard deckt den gesamten Ablauf eines Einsatzes digital ab – von der **Alarmierung über die Einsatzplanung bis zur Berichterstellung** ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Fireboard%20bietet%20Ihnen%20eine%20umfassende,bis%20hin%20zur%20vollst%C3%A4ndigen%20Berichterstattung)) – und bietet Module für Einsatztagebuch, Lagekarte, Kommunikation, Ressourcenmanagement u.v.m. Viele dieser Funktionen sind für Bluelight Hub relevant: So sollte beispielsweise die **Multi-User-Fähigkeit** (“Mehrplatzfähigkeit”) übernommen werden, damit mehrere Mitarbeiter parallel im System arbeiten können ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Das%20Fireboard%20Grundsystem%20erm%C3%B6glicht%20Ihnen,von%20der%20FEZ%20verfolgt%20werden)). Fireboard zeigt auch den Nutzen einer zentralen Synchronisation: Alle Arbeitsplätze lassen sich über ein Portal konfigurieren und Daten austauschen ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Das%20Fireboard%20Grundsystem%20erm%C3%B6glicht%20Ihnen,von%20der%20FEZ%20verfolgt%20werden)). Dieses Konzept spiegelt sich in Bluelight Hubs optionaler Online-Sync wider. Ein weiteres Feature von Fireboard ist die Unterstützung **taktischer Zeichen und Einsatzabschnitte** in der Karte ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Mit%20dem%20Modul%20Lagekarte%20l%C3%A4sst,Informationen%20f%C3%BCr%20taktische%20Entscheidungen%20liefert)) – auch das übernimmt Bluelight Hub, um eine vollwertige Lagedarstellung zu ermöglichen.

**Fireboard** dient als Vorbild für viele Funktionen, doch Bluelight Hub zielt darauf ab, **Verbesserungen** in einigen Bereichen zu liefern:
- **Technologie und UI:** Fireboard ist etabliert, setzt aber auf traditionelle Technologien. Bluelight Hub nutzt moderne Web-Technologien (Tauri/Node) für eine flexibel erweiterbare Plattform und eine **intuitive Bedienoberfläche**. Gerade im Einsatz ist eine einfache, selbsterklärende UI wichtig, damit sich die Nutzer auf die Lage konzentrieren können ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Entwickelt%20f%C3%BCr%20den%20Einsatz%20im,vollst%C3%A4ndig%20auf%20die%20Einsatzsituation%20konzentrieren)). Dieses Prinzip („Bedienung so einfach, dass volle Konzentration auf die Einsatzsituation möglich ist“) wird von Fireboard zwar adressiert ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Entwickelt%20f%C3%BCr%20den%20Einsatz%20im,vollst%C3%A4ndig%20auf%20die%20Einsatzsituation%20konzentrieren)), kann aber mit neuesten UI/UX-Methoden weiter verbessert werden (z.B. klare visuelle Hierarchien, Dark Mode für Nachteinsätze, Touch-optimierte Bedienelemente für Tablets).
- **Offenheit und Integration:** Während kommerzielle Lösungen oft proprietär sind, soll Bluelight Hub **offene Schnittstellen** bieten. Beispielsweise könnten standardisierte **REST/Websocket-APIs** externe Systeme anbinden – etwa Lageboard-Anzeigen, Alarmierungs-Apps (Divera 24/7 Integration) oder Auswerte-Tools. So ließe sich Bluelight Hub in eine bestehende Systemlandschaft integrieren, was Fireboard nur über sein eigenes Portal ermöglicht.
- **Lizenzkosten:** Fireboard ist modular und einige Funktionen sind kostenpflichtig; Bluelight Hub könnte als Open-Source oder vereinheitlichtes System konzipiert werden, damit Hilfsorganisationen es ohne hohe Kosten einsetzen und anpassen können. Die **Grundfunktionen (ETB etc.)** sollten direkt verfügbar sein, ohne erst Module zukaufen zu müssen ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Das%20Fireboard%20Grundsystem%20erm%C3%B6glicht%20Ihnen,von%20der%20FEZ%20verfolgt%20werden)).
- **Customization:** Jede Organisation hat leicht andere Abläufe. Bluelight Hub könnte hier punkten, indem es **konfigurierbar** ist (z.B. Felder anpassbar, eigene Formulare hinterlegbar), während bestehende Lösungen oft fixe Masken haben.

Neben Fireboard gibt es weitere relevante Lösungen:
- **rescueTABLET:** Eine Software zur digitalen Einsatzunterstützung, die durch **Plattformunabhängigkeit** auffällt. RescueTABLET läuft auf Android, iOS und Windows und funktioniert komplett **offline**, indem alle Daten lokal (verschlüsselt) vorgehalten werden ([NEUE BROSCHÜRE](https://rescuetablet.de/documents/rescueTABLET_Datenblatt.pdf#:~:text=rescueTABLET%20steht%20plattform%C3%BCbergreifend%20sowohl%20auf,in%20einer%20Anwendung%20zur%20Verf%C3%BCgung)). Dieses Konzept bestätigt den Weg für Bluelight Hub: Offlinefähigkeit und Multi-Platform-Support sind entscheidend. Außerdem bietet rescueTABLET Kartenfunktionen (Hydrantenpläne, Rettungskarten) und einsatzrelevante Informationen auf einen Blick ([NEUE BROSCHÜRE](https://rescuetablet.de/documents/rescueTABLET_Datenblatt.pdf#:~:text=rescueTABLET%20ist%20die%20mobile%20L%C3%B6sung,DIGITALE%20EINSATZUNTERST%C3%9CTZUNG%20F%C3%9CR%20RETTUNGSKR%C3%84FTE)). Bluelight Hub kann sich hier abschauen, bestimmte Daten (z.B. wichtige Nachschlagewerke oder Kartenlayer) vorzuhalten, um sie im Einsatz parat zu haben. Gleichzeitig besteht bei rescueTABLET Verbesserungspotential in der **Usability** (viele Informationen können auch erschlagen) – Bluelight Hub sollte die Balance zwischen Informationstiefe und Übersicht wahren.
- **HiOrg-Server:** Diese Lösung fokussiert mehr auf **Organisation und Planung** im Hintergrund (Dienstplanung, Personal, Vor-/Nachbereitung von Einsätzen) ([Software Katastrophenschutz | SKD-E](https://www.skd-e.de/katastrophenschutz#:~:text=Eine%20der%20f%C3%BChrenden%20Anbieter%20von,Katastrophenschutz%2C%20Feuerwehr%20und%20anderen%20Hilfsorganisationen)). Zwar ist HiOrg kein direktes Einsatzleit-Tool im Fahrzeug, doch einige Ideen können übernommen werden, z.B. die **Personal- und Materialdatenbank** im Vorfeld und die **Nachbereitung/Dokumentation** nach dem Einsatz. Bluelight Hub könnte perspektivisch Schnittstellen zu Planungstools wie HiOrg bieten, um z.B. Helferdaten oder Terminplanungen zu importieren.
- **Sahana** (Open Source Disaster Management): International gibt es mit Sahana ein Open-Source-Projekt für das Katastrophenmanagement, das Module für Vermisstensuche, Lagerverwaltung etc. bietet. Dies zeigt, dass **Open-Source-Lösungen** machbar sind und durch Community erweitert werden können. Bluelight Hub orientiert sich zwar auf den taktischen Bereich der Einsatzleitung, könnte aber langfristig von einer Community-Entwicklung profitieren (ähnlich Sahana oder auch Projekten wie **Incident Command System (ICS) apps** in den USA).

Insgesamt soll Bluelight Hub die **Stärken bestehender Lösungen kombinieren** – z.B. Umfang und Struktur von Fireboard ([Fireboard Funktionen und Module - Fireboard](https://fireboard.net/produkte/#:~:text=Fireboard%20bietet%20Ihnen%20eine%20umfassende,bis%20hin%20zur%20vollst%C3%A4ndigen%20Berichterstattung)), Offline-Mobilität von rescueTABLET ([NEUE BROSCHÜRE](https://rescuetablet.de/documents/rescueTABLET_Datenblatt.pdf#:~:text=Alle%20Funktionen%20%26%20Module%20von,in%20einer%20Anwendung%20zur%20Verf%C3%BCgung)) – und diese in einer **einheitlichen, modernen Anwendung** bereitstellen. Funktionen, die sich in der Praxis bewährt haben (Einsatztagebuch, Lagekarte, Kräfteübersicht, Kommunikationslog, Aufgabenliste, etc.), werden übernommen. Gleichzeitig wird auf **Verbesserungen in Usability, Flexibilität und Kosteneffizienz** geachtet, damit das System optimal auf die Bedürfnisse des DRK und ähnlicher Organisationen zugeschnitten ist.

## 4. Empfohlene Frameworks & Tools

Für die Umsetzung von Bluelight Hub kommen folgende Technologien und Werkzeuge in Betracht, um die genannten Anforderungen optimal zu erfüllen:

- **Frontend:** Empfohlen wird die Kombination aus **Tauri** und einem modernen Web-Framework. Als UI-Framework bieten sich z.B. **React** (mit Bibliotheken wie Material-UI oder Chakra UI für konsistente Bedienelemente) oder **Vue.js** (mit Vuetify) an, da diese eine reiche Ökosystem und Responsive-Design unterstützen. Tauri ermöglicht daraus native Desktop-Anwendungen zu bauen ([Electron | Marcin Skrzyński's Blog](https://marcin.codes/tags/Electron/#:~:text=Tauri%20is%20a%20framework%20for,it%20with%20NodeJS%20server%20aside)). Alternativ käme **Electron** in Frage – ebenfalls Web-Technologie für Desktop –, jedoch ist Electron ressourcenhungriger (Chromium-Browser pro App). Tauri nutzt die vorhandene WebEngine des OS und ist dadurch schlanker ([Electron | Marcin Skrzyński's Blog](https://marcin.codes/tags/Electron/#:~:text=Tauri%20is%20a%20framework%20for,it%20with%20NodeJS%20server%20aside)). Für eine mögliche mobile App kann der gleiche Code als **Progressive Web App (PWA)** dienen oder mit Frameworks wie **Ionic/Capacitor** bzw. React Native wiederverwendet werden. Wichtig fürs Frontend ist zudem ein **state management** (Redux, Vuex oder Zustand/Pinia je nach Framework), um die komplexen Einsatzdaten zuverlässig zu handhaben. UI-seitig sollte ein **responsive Layout** verwendet werden, das auf großen Bildschirmen im ELW ebenso gut funktioniert wie auf Tablets. Libraries für Diagramme (Einsatzstatistiken) oder PDF-Generierung (Berichte) könnten ebenfalls zum Einsatz kommen.

- **Backend & Datenbank:** Wie geplant, **NestJS** als Backend-Framework auf Node.js-Basis. NestJS bietet out-of-the-box eine solide Architektur (Module, DI, Middleware) und unterstützt gängige Pakete. Für die lokale **Datenbank** ist **SQLite** die erste Wahl – diese kann z.B. über TypeORM oder Prisma ORM in NestJS eingebunden werden. SQLite ist leichtgewichtig und dennoch robust; viele Offline-First-Anwendungen setzen darauf ([Local First / Offline First | RxDB - JavaScript Database](https://rxdb.info/offline-first.html#:~:text=Local,server%2C%20the%20gateway%20for%20all)). Sollte eine relationale DB ungeeignet sein (z.B. wegen stark flexibler Daten), könnte **NeDB** oder **PouchDB** als In-Memory/Datei-NoSQL genutzt werden, aber i.d.R. bietet SQLite genügend Flexibilität (mit Joins, etc.). Für die **optionale Server-Cloud** könnte eine skalierbare DB wie PostgreSQL oder MongoDB genutzt werden – NestJS unterstützt beide via ORM/Driver. Als ORM wird **TypeORM** empfohlen (nahtlos in Nest integrierbar, unterstützt SQLite und andere DBs). Alternativ ist **Prisma** sehr komfortabel in TypeScript. Zur Dateispeicherung (Berichte, Bilder) im Cloud-Backend empfiehlt sich die Integration der **AWS SDK** für S3 oder alternativ Nextcloud/WebDAV für selbstgehostete Speicher, um Dateien wie PDF-Formulare abzulegen ([Store Reports and Logs on S3—JVM Cluster · digital.ai Release](https://docs.digital.ai/release/docs/how-to/store-report-and-logs-s3-jvm#:~:text=You%20can%20configure%20Digital,your%20existing%20data%20if%20necessary)). Für Authentifizierung setzt man am besten auf **JWT (JSON Web Token)** mit Passport.js in NestJS, was durch zahlreiche Tutorials und Guards gut unterstützt ist ([Authentication | NestJS - A progressive Node.js framework](https://docs.nestjs.com/security/authentication#:~:text=Let%27s%20flesh%20out%20our%20requirements,that%20contain%20a%20valid%20JWT)). NestJS bringt außerdem eine eingebaute **WebSocket Gateway**-Funktion mit, die hier für die Live-Kommunikation genutzt wird. Testen lässt sich das Backend mit Tools wie Jest (Unit Tests) und beim Deploy evtl. via Docker-Container, um auf dem ELW-Laptop eine portable Server-Umgebung zu haben.

- **Kartenlösung:** Für die **Lagekarte** kommen bewährte Mapping-Frameworks infrage. **Leaflet** ist eine leichte JS-Bibliothek für interaktive 2D-Karten und aufgrund zahlreicher Plugins (für Offline-Karten, Zeichentools, Markercluster etc.) sehr geeignet. Leaflet kann OSM-Karten laden und auch mit lokalen Tile-Packs arbeiten ([Microsoft Word - Y4710](https://www.atlantis-press.com/article/25839801.pdf#:~:text=on%20OSM%20,the%20security%20of%20the%20system)). Alternativ bietet **OpenLayers** mehr Features für komplexe GIS-Anwendungen (aber auch höhere Einarbeitung). **Mapbox GL JS** wäre eine Option für hübsche vektorbasierte Karten, erfordert aber entweder Mapbox-Service oder eigene Vektor-Tiles. Da Offline-Fähigkeit wichtig ist, wäre die Kombination **Leaflet + MBTiles** sinnvoll: Man kann mit Tools (wie Maperitive oder TileServer) benötigte Kartenausschnitte als MBTiles (SQLite mit Tiles ([Microsoft Word - Y4710](https://www.atlantis-press.com/article/25839801.pdf#:~:text=that%20it%20doesn%E2%80%99t%20support%20the,Mbtiles%20format%20SQLITE%20database%20file))) vorhalten und im Einsatz laden. Für Geocoding (Adresssuche) kann **Nominatim** verwendet werden (ggf. offline mit Photon). Taktische Zeichen könnten über ein **Icon-Library** (es gibt BOS-Symbols als SVG) realisiert werden, die Leaflet als Marker-Icons nutzt. Für Routing oder Entfernungsberechnung (z.B. Radius um Einsatzstelle) gibt es ebenfalls Leaflet-Plugins. Sollte 3D relevant werden (etwa Höhenprofil bei Bergrettung), könnte später CesiumJS oder Mapbox für 3D ergänzt werden – initial reicht aber eine 2D-Karte. Wichtig ist die Performance auf typischer ELW-Hardware, daher auf zu komplexe Visualisierungen verzichten und caching nutzen. 

- **Kommunikation & Vernetzung:** Im lokalen Netz des Einsatzleitwagens kann der Datenaustausch über **normales TCP/IP** erfolgen – d.h. die Clients greifen via IP/Hostname auf den NestJS-Server zu. Für die **Service Discovery** (Auffinden des Servers im Netz) könnte **mDNS/Bonjour** eingesetzt werden, damit Clients automatisch den Server finden (z.B. „bluelight-hub.local“). Die Echtzeitkommunikation wird über **WebSocket** oder ggf. **Socket.io** (falls Fallbacks nötig sind) realisiert, damit alle Teilnehmer synchron bleiben. NestJS bietet hier integrierte Gateways, sodass serverseitig Ereignisse gebroadcastet werden können (z.B. neuer ETB-Eintrag -> an alle senden). Für die optionale Internetanbindung sollte auf **HTTP-REST** mit JSON gesetzt werden (leicht zu debuggen, kompatibel), abgesichert durch **JWT Tokens** oder API-Keys ([Authentication | NestJS - A progressive Node.js framework](https://docs.nestjs.com/security/authentication#:~:text=Let%27s%20flesh%20out%20our%20requirements,that%20contain%20a%20valid%20JWT)). Eine Möglichkeit ist auch, den zentralen Server via **VPN** aus den Fahrzeugen zu erreichen, falls direktes Internet unsicher ist. In puncto Protokoll kommen **HTTPS (SSL/TLS)** und ggf. **WSS** (WebSocket Secure) zum Einsatz, insbesondere über WAN. Für Push-Benachrichtigungen (z.B. an mobile Geräte) könnte eine Integration mit einem Dienst oder via Web Push API erfolgen – aber innerhalb des Fahrzeugs reicht das Live-Update. Falls gewünscht, kann auch eine **E-Mail/SMS-Schnittstelle** angebunden werden (z.B. automatische Lageberichte an vordefinierte Empfänger). Zusammengefasst setzt Bluelight Hub hier auf Standard-Webtechnologien, die sich bewährt haben, um Stabilität und Kompatibilität zu gewährleisten.

## 5. Schritt-für-Schritt-Plan (Roadmap)

Die Entwicklung von Bluelight Hub erfolgt iterativ in aufsteigenden Funktionalitäten. Ein schrittweiser Plan könnte wie folgt aussehen:

1. **Phase 1 – MVP erstellen:** In der ersten Phase wird ein **Minimalprodukt** entwickelt, das die Grundbedürfnisse abdeckt. Fokus liegt auf dem **Einsatztagebuch-Modul** als Herzstück, da dieses für die Dokumentation unverzichtbar ist. Man richtet das Projektgerüst ein: NestJS Backend mit SQLite-Anbindung, grundlegende API Endpoints (für ETB-Einträge, Login) und ein Tauri-Frontend mit Loginmaske und einer simplen ETB-Oberfläche. Bereits hier wird Mehrbenutzerfähigkeit berücksichtigt: Mehrere Clients können sich verbinden und ETB-Updates per WebSocket erhalten. Sicherheitslevel MVP: einfacher Nutzerlogin (Lokalnutzer), aber noch ohne komplexe Rechte. Dieses MVP wird auf einem ELW-Laptop getestet, um Feedback von Endanwendern (Einsatzkräfte) einzuholen – etwa in einer Übung.

2. **Phase 2 – Kernmodule ausbauen:** Aufbauend auf dem MVP werden die weiteren **Hauptmodule** implementiert. Zuerst das **Lagekarte-Modul**, da visuelle Lageführung sehr gefragt ist. Integration von Leaflet mit Online-OSM zu Beginn; später folgt Offline-Karten-Support. Parallel wird die **Fahrzeug- und Kräfteverwaltung** entwickelt: Erfassung von Fahrzeugen, Anzeige des Status und eventuell eine einfache Statusänderungsfunktion. Die **Patientenverwaltung** kommt als nächstes hinzu, zumindest in Grundzügen (Patient anlegen, Status/Triage zuweisen, Liste anzeigen). Auch das **Kommunikationsmodul** für Nachrichten wird in dieser Phase prototypisch umgesetzt, um Funkmeldungen zu erfassen. Jede Fertigstellung eines Moduls wird mit Nutzern geprüft – z.B. in Form von Teil-Deployments im ELW, um zu sehen ob Bedienkonzepte passen. Technisch wird in dieser Phase auch die Datenpersistenz erweitert: komplexere Datenmodelle in SQLite, Beziehungen (z.B. Fahrzeug -> Abschnitt). Zudem werden erste **Exportfunktionen** geschaffen (z.B. PDF-Export des Einsatztagebuchs).

3. **Phase 3 – Erweiterung und Verfeinerung:** Nun werden **ergänzende Features** hinzugefügt und bestehende Module verfeinert. Das **Aufgaben-Modul** (Auftragsverwaltung) wird implementiert, um To-Dos zu managen. Die Lagekarte erhält Erweiterungen wie Zeichentools, taktische Symbole und Offline-Karten-Support (Einbindung vorab geladener Tiles ([Microsoft Word - Y4710](https://www.atlantis-press.com/article/25839801.pdf#:~:text=on%20OSM%20,the%20security%20of%20the%20system))). Die Patientenverwaltung wird ausgebaut (Transportdokumentation, vielleicht Anbindung an Klinikmeldungen falls relevant). Es erfolgt die Integration einer **Benutzer- und Rechteverwaltung**: in dieser Phase könnte man verschiedene Rollen definieren (z.B. “Einsatzleiter” darf alles, “Dokumentation” darf nur ETB schreiben, etc.). Auch an die **Performance** wird gefeilt – z.B. Caching von häufigen Abfragen, Optimierung der WebSocket-Nutzung. In dieser Phase ist die Software in Summe schon einsatzfähig für kleinere Lagen; ein **Beta-Test** in realen Einsätzen (parallel zur klassischen Doku) wäre wertvoll, um Stabilität und Nutzen zu bewerten.

4. **Phase 4 – Online-Synchronisation und Cloud:** Nachdem lokal alles rund läuft, wird die **optionale Online-Komponente** umgesetzt. Ein zentrales Backend (NestJS in der Cloud oder Rechenzentrum) wird eingerichtet mit Benutzerverwaltung und mandantenfähiger Datenbank, sodass mehrere Fahrzeuge/Einheiten dort synchronisieren können. Implementierung von **Sync-Mechanismen**: der lokale Server puffert Änderungen und sendet sie via REST/WebSocket an den zentralen Server, wo sie in einer zentralen DB (z.B. PostgreSQL) landen. Umgekehrt können neue Infos vom zentralen Server (etwa Lageänderungen durch die Leitstelle) an den ELW geschickt werden. Wichtiger Aspekt ist die **Kollisionsvermeidung** – ggf. wird ein einfacher *Last-Write-Wins* oder Zeitstempelabgleich genutzt, da komplexes Merging für unsere Zwecke meist nicht nötig ist. Zudem wird in dieser Phase **Security hochgefahren**: die Kommunikation mit dem Cloud-Server wird voll verschlüsselt und Authentifizierung mit JWT/Access-Token aktiviert ([Authentication | NestJS - A progressive Node.js framework](https://docs.nestjs.com/security/authentication#:~:text=Let%27s%20flesh%20out%20our%20requirements,that%20contain%20a%20valid%20JWT)). Es erfolgen Tests, indem man simuliert, dass mehrere ELWs an einem Einsatz arbeiten und schauen, ob die Sync funktioniert. Auch **Skalierungstests** sind sinnvoll (wie verhält sich das System mit z.B. 100 Patienten oder 50 gleichzeitigen Aufgaben).

5. **Phase 5 – Feinschliff und Vorbereitung des Betriebs:** In der finalen Phase werden **Bugfixes** und **Usability-Verbesserungen** basierend auf Beta-Tests umgesetzt. Die Oberfläche wird poliert (einheitliche Icons, vielleicht Einbindung eines BOS-Symbolsatzes, übersichtliche Farbgebung – z.B. Statusfarben für Fahrzeuge). Eine **umfassende Dokumentation** (Handbuch für Anwender, technische Doku für Admins) wird erstellt. Schulungen könnten geplant werden, um die Helfer mit dem System vertraut zu machen. Weiterhin wird ein **Backup-/Recovery-Konzept** finalisiert (z.B. tägliche automatische Exporte der DB). Falls noch Zeit/Bedarf: Implementierung von weiteren Nice-to-have Features wie z.B. **Einsatzchat** für Stabsmitglieder, **Analytics** (Auswertung von Einsatzdaten über Zeit), oder **Schnittstellen** (Divera 24/7, HiOrg-Server Importe). Schließlich erfolgt die **Inbetriebnahme**: Bluelight Hub wird auf dem ELW installiert (ggf. nebenher auf Tablets) und in den Echtbetrieb überführt. Man definiert Support-Strukturen (wer wartet die Software, wie werden Updates verteilt – z.B. via einfachem Installer oder Docker-Image). Das Projekt bleibt danach iterativ offen für Erweiterungen, getrieben von Feedback der Nutzer und neuen Anforderungen aus der Praxis.

Durch diesen gestuften Plan wird sichergestellt, dass zunächst ein einsatzfähiges Kernprodukt entsteht, das schrittweise um Funktionalität ergänzt wird. Risiken können früh erkannt und adressiert werden, und die Anwender werden von Beginn an in die Entwicklung einbezogen, was zu einer praxisnahen, benutzerfreundlichen Lösung führt.

